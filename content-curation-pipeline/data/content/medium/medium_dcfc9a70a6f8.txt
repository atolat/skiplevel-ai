Software Engineering Is Not About Typing, It's About Thinking

Best practices in software engineering prioritise and reward repetitive work. They support working in ways that allow us to make frequent decisions and adapt to changing situations. These ideas are almost universal and appear to be necessary for successful large-scale engineering initiatives, although the concept is sometimes taken too far, which can be detrimental. While it is nearly always a good idea to be able to iterate rapidly and alter our thoughts, this does not mean that we should not take the time to think before acting.

When confronted with an issue, it is frequently more productive to first thoroughly analyse the universe of potential solutions than leaping quickly to thoughts of "how can I fix this with code". By the time code begins to flow into an editor, there should be a clear understanding of the general plan; what is being built towards? Which principles are being programmed against? Should new core notions be introduced to this section of code to help with implementation? Which preexisting concepts will need to be modified? It's very simple to wind up just "coding by accident" without answers to these and other problems, wading through unforeseen problem after problem until eventually solution emerges that seems to work well enough, but most likely isn't implemented as well as it could've been.

The more inexperienced an engineer is, the stranger this may sound to them. After all, their job is to write code, so how can thinking be more valuable than actually doing? One of the best explanations can be found in a pithy quote for which I've been unable to find a source:

Weeks of coding can save you hours of planning.

The point is that it doesn't matter how rapidly someone can create code if they're doing it for the wrong cause. One of the worst potential outcomes for a software engineer is to spend days or weeks working on a solution only to discover that they've been constructing the wrong thing the whole time. Of course, this isn't always the engineer's fault (and agile methodologies should help to identify problems like this earlier in the process), but the fact remains that there is almost always more than each of us can do individually to ensure that we're solving the right problems in the best way possible.

The idea can also be difficult to implement in practice for many reasons:

If the problem is completely novel, attempting to write some code can be a good way to better understand the problem space

Writing code is, for many engineers, a lot more fun and approachable than sitting around and thinking about problems in the abstract

There is a lot of uncertainty involved in abstract thought of this nature; how does one know that they're thinking about the right things?

Spending too much time thinking and planning ahead of time can be just as bad as not spending enough; how does one know when to stop thinking and start doing?

One technique I prefer to take is to establish what I consider to be the basic concepts that underpin the situation. Most difficulties can be broken down into smaller ideas that are more or less independent of one another. This should sound familiar to most engineers because it is quite close to the essential software design principles of coupling and cohesion. Decoupling is primarily a technical procedure, whereas identifying these key notions is theoretical. The goal is to look for concepts within the problem itself so that we may construct our technological bounds around the conceptual boundaries that exist within the core of the challenge at hand. More specifically, the best outcome is when the identified concepts are loosely coupled, yet highly cohesive.

Consider a command-line application that can produce devcontainer specs for users by declaratively integrating tools rather than requiring them to manually write the configuration files. Writing devcontainers specifications and their corresponding dockerfiles can be a bit of a pain because of the unexpected interactions between the running container and the user's development environment; for example, the container's timezone should be synchronised with that of the user, the UID of the user in the container should match the UID of the external user, and SSH passthrough authentication should "just work", but these are not features that devcontainers provides. The idea is that the tool should be able to take a simplified configuration file that allows the user to say: "I want to use Rust, Git, Vim, and the Oil shell", click a button, and get a fully-instrumented and repeatable development environment.

Consider forcing yourself to think about this problem: what key notions can you uncover that would make sense to build this tool around? Once you've finished, expand the section below to see what I discovered. Are your concepts different than mine? Maybe I overlooked something!

Core Concepts

Repository: the highest-level construct supported by the tooling; usually a versioned-controlled source repository, can hold one or more Projects

Project: a desired development experience associated with a subset of its Repository. Has a single Configuration at any point in time

Configuration: a point-in-time instance of a Project. Each Configuration generates a single unique Devcontainers spec and associated Docker image

Host: the host environment from which the tool is being executed, used as a source for information that must be injected into a Configuration

Environment: an actively running instance of a Configuration, usually managed by the Editor

Editor: the source code editor that will be used to run the Devcontainer

Tool: an individual piece of functionality that can be composed with other Tools to provide a development environment

While this is a simplified list, it should be evident that these are concepts related to the problem rather than specific technical decisions. Nothing in the list above specifies how the tool will deal with any of these notions; it simply states that they exist and should be examined during development. That is one of the reasons it is critical to think before creating code: we want to avoid anchoring our cognitive process to previous experiences.

More technical questions then arise from consideration of these concepts:

Should Repositories be restricted to containing only a single project? How might that effect users of monorepos?

It's possible that running Environments will drift from the current Configuration (if an environment is left running after the configuration is modified); does this matter?

The Configuration is likely to have to understand the different Editors supported by the tool; how should that be accomplished?

How should the tool deal with different Host platforms?

How can Tools be composed with one another when generating a final specification?

And from here, the ability to begin iterative development as usual against these concept emerges.

It's important to note that I'm not advocating for design by committee, waterfall development, architecture astronauts, or any other anti-patterns that upset engineers who simply want to get things done. Thinking before typing is an individual action that any engineer can practise to potentially improve the end results of the work they produce. Writing some code to explore the problem space, for example, is a fantastic idea - but if you're going to get started right away, you might want to remind yourself to consider tossing that experimental code away and thinking about the problem before you go too far down any single road. Especially if problem discovery is the purpose of a prototype, the possibility of falling into the XY problem is ever-present.

Another aspect of this idea that I find very useful is that it can be used to help explain some of the difficulties involved in software engineering to less technical individuals, especially stakeholders and executives. Measurement of engineering teams, for example, is a hot topic lately off the tails of the success of DORA metrics, the relatively recent release of the SPACE framework, and then the unfortunate McKinsey system that has drawn some misgivings from experienced engineering leaders.

SPACE, in particular, does an excellent job of recognising that there is much more to engineering than the code that an engineer creates. While many people struggle to understand the complexities of the development process, it is an engineering leader's responsibility to advocate for their teams and help stakeholders understand where time is spent and why things take as long as they do. Focusing on the importance of planning, design, and thinking can help leaders express these topics in terms that everyone, regardless of technical ability, can grasp.

Because most software engineering is an inherently creative endeavor, it's difficult to distill the daily activities of an engineer down to the type of cleanly measurable metrics that many executives (particularly those with less familiarity with the engineering process) would like to see. The glue engineer for example may be critical to the overall function of their team, but any attempts to measure that individual's impact by focusing on their issue completion or commit history is bound to fail in the general case. This is why experienced engineering leaders try to focus more on measuring outcomes over outputs.

The most interesting aspect of this difficulty of measurement is that the difficulty tends to grow with the seniority of the engineer in question. The more experienced and impactful someone is, the more likely it is that they're impact is coming from intangibles like their ability to influence others. While this is a generalization, there's a good reason that many of the open source engineering progression frameworks focus on influence rather than output at their highest engineering levels. These are just a few of the tools that can be used to help socialize this type of understanding of the SDLC throughout an organization.

So, every now and then considering reminding your engineers: software engineering is about thinking, not typing.