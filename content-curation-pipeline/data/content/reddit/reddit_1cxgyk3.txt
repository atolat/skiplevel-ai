# What are the most overrated/underrated technologies/ideas in software engineering in your opinion?

Overrated: 

Microservices (yes, it's me who created the recent thread about MSA). The thread has some insightful stories and arguments, but I still feel like the hype around microservices did the industry a bad favor. 

MongoDB (closely related to the PG point below). I have several times heard my colleagues discuss MongoDB and want to use it at work. Every single time, my immediate reaction was to ask why and suggest using Postgres instead with its JSONB columns.



Clean/hexagonal architecture - I think that the underlying ideas (dependency inversion, single responsibility and the rest of SOLID) are great ways to reason about architecture. That said, the marketing hype about clean architecture seems to have created a cult of religious fans to the point where abstractions and layers of indirection are created just because that follows what Uncle Bob wrote in his article. Also, the popular argument of "now we can swap the database every day" is so unrealistic in my opinion. I don't really remember ever needing to unexpectedly swap a database. Maybe, I'm wrong. 

Underrated: 

Postgresql - even though it has a great reputation these days, I still think a lot of people would benefit a lot from knowing more about its features and potential. My personal favorite is using PG's FOR UPDATE SKIP LOCKED feature to implement a simple queue. Whenever I need a task queue, I immediately reach for it. 

Presentation/writing skills: I am not a great presenter and speaker myself, but the more I work as a software engineer, the more I realize that being concise, accurate, and engaging in your writing/speaking is a valuable asset. Not only does it make you more efficient in communication, your colleagues like you more, and your managers are likely to give you a promotion. 

What are yours?

## Comments

### Comment 1 by u/Antique-Stand-4920 (327 points)

Underrated:

- Regularly deleting software, infrastructure, data, documentation, etc that nobody uses. 

- Building software with the assumption that people have better things to do than to fiddle with the software. Same thing for architecture.

- Being wary of tools or dependencies that lack support for when things break.

#### Reply 1 by u/Drevicar (113 points)

One of my teams told me today that they don't trust their tests, so I told them to delete all the tests they don't trust and only replace them if they cover code that is both of value and needs to change. Otherwise I know a few end to end tests cover all the code that no one wants to touch but we need to keep around.

#### Reply 2 by u/CalvinCalhoun (28 points)

I‚Äôm a cloud engineer/devops fuck but holy shit regularly deleting stuff. It takes me a month of pulling teeth to get the approvals to remove resources that are doing nothing and costing thousands. Drives me nuts

#### Reply 3 by u/nutrecht (12 points)

> documentation, etc that nobody uses.

Or; why Wiki's are shit for documentation. "Confluence; where information goes to die" ;)

#### Reply 4 by u/ForgotPassAgain34 (3 points)

> Building software with the assumption that people have better things to do than to fiddle with the software

Sane defaults bring the best of both worlds

#### Reply 5 by u/lucid00000 (1 points)

I find these days that I feel more accomplished when my PRs remove more code than it adds. My company has too much of a tendency to pile junk on junk without ever cleaning anything up.

#### Reply 6 by u/totoro27 (-2 points)

> Regularly deleting software, infrastructure, data, documentation, etc that nobody uses.

Why? How do you know that data wouldn‚Äôt be more valuable in the future than whatever disk space costs it incurs to keep it?

**edit:** not sure why I‚Äôm being downvoted. This is a genuine question directed at engineers with more experience than me.

### Comment 2 by u/time-lord (199 points)

I don't have a problem with clean architecture, but I find that the purists make it worse than it actually is.

#### Reply 1 by u/Buttleston (92 points)

This is probably true for literally everything in programming that is a philosophy.  Agile, TDD, whatever

#### Reply 2 by u/funbike (5 points)

Agree.  There's a significant sane subset.  Plus the author's personal views have caused controversy.

Generally, I am a fan of the core concepts.

#### Reply 3 by u/External-Brilliant-7 (2 points)

The issue with clean architecture is "clean".

Purists tend to think that everything needs to be clean then, meaning by the book. This actually creates a big (organisational  || technical) mess, ironically.

### Comment 3 by u/LloydAtkinson (390 points)

Sequence diagrams!

Holy fuck why are they so underused. Nothing makes me seethe more than when I see some nebulous ‚Äúarchitecture team‚Äù create THE most unreadable unhinged convoluted half-arsed flow diagram with shit flying everywhere.

It‚Äôs also much easier to create a sequence diagram with code (like D2 and Mermaid) too.

#### Reply 1 by u/MargretTatchersParty (46 points)

This and visual documentation.

#### Reply 2 by u/Schmiddi-75 (67 points)

Mermaid is such a great tool. Well integrated in many services, including Github, Confluence etc.

#### Reply 3 by u/lynxtosg03 (41 points)

When acting in a Lead capacity, I require design defenses for major changes that require at least a sequence diagram and any other uml-like class, state, etc diagram you find necessary to justify your designs. It's always a beneficial endeavor.

#### Reply 4 by u/Jestar342 (14 points)

plantuml has many diagram formats that I have found to be very useful over the years as a technical leader - including sequence diagrams.

#### Reply 5 by u/MrIcedCafeMocha (14 points)

Wow! Thank you for mentioning these! I've got some documentation to write and never knew about D2 or Mermaid. Using D2 right now!

#### Reply 6 by u/[deleted] (12 points)

Sandi Metz in "Practical Object Oriented Programming" introduced me to them, and I don't understand why in my comp sci class in the mid 2000s where we covered just about every sort of UML diagram did we never cover *those.* Because man those are genuinely useful.

#### Reply 7 by u/seacompanies (6 points)

A very original answer IMO. I never stopped to think about it but would say you're correct. I myself rarely reach for them and should probably do it more often.

#### Reply 8 by u/MateriaGris80 (3 points)

Sequencediagram.org

#### Reply 9 by u/RozenKristal (5 points)

Recently i made a sequence diagram and someone told me it was too technical‚Ä¶ i guess if you shared it with other team like middleware they cant read it somehow?

#### Reply 10 by u/mcampo84 (3 points)

PlantUML is amazing for this. Plus, you can commit the code to a VCS and watch the changes happen over time.

#### Reply 11 by u/FlowOfAir (3 points)

One time I built such a diagram to tackle a particularly complicated problem. It was dead easy to spot issues before I wrote a single line of code when it went through the eyes of my colleagues, and it was even easier to bring the idea down to code.

Folks. Make diagrams. Let your peers review that before reviewing your code. You will be appreciated.

#### Reply 12 by u/macca321 (2 points)

You can even output log messages with mermaid code then grep it to build actual sequence diagrams

#### Reply 13 by u/Doctor_Beard (2 points)

There's a great project for the JVM called Living Sequence Diagrams! Definitely worth checking out. https://github.com/lsd-consulting

#### Reply 14 by u/humpyelstiltskin (2 points)

honestly, diagrams in general. People seem to be using them less and less and makes understanding complex themes really difficult and cumbersome

#### Reply 15 by u/crusoe (1 points)

Add Data Context Interaction modeling to the mix with sequence diagrams.


The guy who developed it uses all sorts of dynamic language terms and metaprogramming.¬†


But with zero cost wrapper classes in Rust, you can get 90% of the way there and it keeps you from polluting your base classes with traits for a given domain.


It can map 1to1 with sequence diagram flow.


It reminds me a lot of the morphs/costumes/actors ( not real Actors but the idea of a domain object taking on a role ) in Squeak/Morphic


I implemented the common DCI example task of taking a sequence diagram of bank operations and implementing them.


Rust was capable of heavily optimizing everything away in many cases.¬†


On one hand it's kinda chatty


On the other hand it's super easy to read and match up with the docs.

#### Reply 16 by u/tanepiper (1 points)

I recently launched out internal Content Model docs - as it's not based on a spec, we started wrapping it in one - and with this we can see the relationships - so I threw it at some mermaid code and it make *really nice* 1..1 and 1..n relationship diagrams on the fly.

#### Reply 17 by u/xKommandant (1 points)

Because of the mermaid mention:
Markdown is underrated. No. I don‚Äôt want to use whatever your stupid online tool is, I can do all the documentation anyone will ever need in md files with mermaid.

### Comment 4 by u/RangeSafety (215 points)

Underrated:

KISS. Keep It Stupid Simple. Since the dawn of microservices years, it has become a fashion to create the product in the most complex ways possible.

Knowledge of hardware: I see many programmers imagining a for cycle as a magical thing that the processor just executes out of the blue. There is no thinking about the performance penalties of our actions, since the hardware has become so cheap.

Having an end-to-end oversight of the product from both lifecycle / business point of view and technical point of view. The luxury to only having to deal with a single aspect of an application makes people lazy.

#### Reply 1 by u/dondraper36 (82 points)

Also known as RDD, resume-driven development :)

#### Reply 2 by u/ancientweasel (13 points)

KISS and YAGNI.

Writing code the documents the domian and workflows instead of being a frameworker.

#### Reply 3 by u/[deleted] (7 points)

> I see many programmers imagining a for cycle as a magical thing that the processor just executes out of the blue.

can you explain what you mean by this?

#### Reply 4 by u/External-Brilliant-7 (2 points)

This kind of concepts (like "KISS") do not mean anything.

Microservices keep things simple and stupid. Just on the domain level.

But they don't keep things simple and stupid in terms of services orchestration & communication, for instance.

This is why I think that these concepts suck. They do not mean anything. These are just concepts that are used by engineers when it goes along their way to think.

#### Reply 5 by u/darkapplepolisher (1 points)

Unless you're working embedded systems, you're responsible for compiler development, or that you're working at such a low level that you know how to coerce the compiler to use the hardware correctly, I'd argue that knowledge of hardware is overrated.

For everybody else I didn't carve out an exception for, there's a compiler or interpreter in between your code in the hardware, and until you've mastered that, you have no way to bridge the gap between hardware and code (aside from inline assembly, I suppose).

And then there's the most obvious matter that a majority of us are working on difficult enough high level problems (or shorter deadlines) and don't have the luxury of devoting time to optimizing through thorough knowledge of the compiler and hardware.

### Comment 5 by u/metaphorm (79 points)

>Underrated: Postgresql

Absolutely! Postgres is an extraordinary technology and they just give it away for free!

#### Reply 1 by u/[deleted] (20 points)

[deleted]

#### Reply 2 by u/mspaintshoops (12 points)

Can you expand a bit? I use Postgres so often and I‚Äôm not really sure what differentiates it from the alternatives. Seems like we landed on the correct solution but I‚Äôm curious why

### Comment 6 by u/PM__YOUR__DREAM (106 points)

Overrated: no or low code solutions. 

Almost every single one I've written grew out of what the framework could support and did not scale or handle technical debt well at all.

#### Reply 1 by u/CommandersRock1000 (27 points)

A low-complexity solution is easier to do in "low code".

But a complex solution is a nightmare with it. Obviously even with actual code it's rough, but with "low code" it just becomes impossible to understand.

#### Reply 2 by u/nutrecht (12 points)

> Overrated: no or low code solutions.

They're not just overrated. They're a pure scam. Plain and simple. They rely on vendor lock-in and sunk cost fallacy and even then I've seen more projects trying to move *away* from them, then implementing them.

In our group we're trying to get rid of Outsystems. It's complete garbage and development in Outsystems is not faster, it's actually slower.

#### Reply 3 by u/[deleted] (8 points)

[deleted]

#### Reply 4 by u/DesiBail (1 points)

>Overrated: no or low code solutions. 

This is about to get a million times worse. I have seen examples. It's the best example of instant business manager ego gratification.

### Comment 7 by u/Acceptable-Wasabi429 (32 points)

Underrated

Version control - A badly maintained codebase is a one way ticket to a black box.

Linux - Not much to say here. The best servers are Linux servers. Knowing your way around the command line and file systems is fundamental.

CICD/DevOps - I know devs are supposed to have a baseline understanding of this, but so many orgs criminally under hire for DevOps Engineers and leave good devs at risk of burnout handling complex deployments.

Overrated:

Low/No code tools - They all suck. It‚Äôs a bunch of half baked crap marketed/sold to business users that will never have to maintain them.

NoSQL - there are legitimate use cases for it, but they‚Äôre far less common than the marketing hype would have people believe.

#### Reply 1 by u/cheeman15 (6 points)

Following your thought process I would add Docker to underrated. Of courser there were predecessors but it brought a change so sudden and so well adopted it changed the way we think.

#### Reply 2 by u/[deleted] (1 points)

Worked with low code for a year and a half and it's terrible stuff. The devs that all come from the business are enabled fast to build stuff but a lot is spagetthi that's very hard to maintain. I love how putting all variables on global is the norm and then you get names like strCustomerClientSpecialBusinessIDInvoicesFromBusinessPartner (yes like half prefx shit with its type...).

### Comment 8 by u/false79 (157 points)

(Extremely) Overrated: AI tooling. The hype was to make coding instantly irrelevant. But I found it hasn't dramatically changed my day to day. At the same time, one cannot ignore it because if you're not using it, chances are that your competition is.

Underrated: JVM. Sh!t is still kickin' in this day + age.

#### Reply 1 by u/SKabanov (57 points)

AI-based autocomplete in IntelliJ has been great for me. It's not writing all the code - and it's not perfect, of course - but the small gains in avoiding having to type repetitive boilerplate code really add up.

#### Reply 2 by u/[deleted] (59 points)

[deleted]

#### Reply 3 by u/thatVisitingHasher (36 points)

AI hype reminds me of JS hype. ‚ÄùOh my god the first 15 minutes of using this tool is amazing! This changes everything!‚Äù A year later. ‚ÄúYeah, we‚Äôre blocked because of XYZ. We wish we used this other tool.‚Äù

#### Reply 4 by u/[deleted] (5 points)

[deleted]

#### Reply 5 by u/Drevicar (15 points)

I absolutely hate the Java programming language, but the JVM is one of the most optimized pieces of tech in our industry, right up there with v8 for JS. I always say that Java is the worst language that runs on the JVM.

#### Reply 6 by u/general_dispondency (8 points)

The JVM is one of the greatest technological accomplishments in the last 30 years. It's light-years ahead of any other runtime and it gets better every version. The new virtual threads are killer. Why bother with async/await when you can just have the runtime deal with it. You want 10 million threads on your webserver? No problem.¬† The other underrated thing is the Java ecosystem. I spend most of my time in TS and a few other languages these days and just damn. Java is verbose, but I had to write so much less code to get a new app to prod.

#### Reply 7 by u/Creature1124 (27 points)

I‚Äôll go against the grain and say AI tooling is actually underrated with devs. The rest of the world is putting it to use for everything (my partner, a process engineer / business analyst gets impressive results with ChatGPT), but I hardly see devs use it. I was very wary of it but recently started using it a little in my IDE and it‚Äôs not going to make me a 100x engineer, but it‚Äôs more helpful than I would have thought.

#### Reply 8 by u/West-Peak4381 (3 points)

Man, I had to update an old AngularJS application that hadn't been touched in years. Never worked with AngularJS,  Could not have figured it out without chat gpt, it was like a better search engine because most Angular related google searches have to do with Angular 2.

#### Reply 9 by u/Guilty_Serve (5 points)

I'm going to push back here. AI tooling is pretty damn great. It sucks at coding, but it's damn well amazing on teaching you what to learn and providing documentation. I don't miss being a Google/Ctrl+F expert

#### Reply 10 by u/Gwolf4 (2 points)

AI has helped me a lot for small things that i cannot even have to think about. I also love jvm using kotling for a future saas i am building rn and I love it.

#### Reply 11 by u/orangeowlelf (2 points)

ChatGPT has saved me many hours at this point.  I generally offload all of my grunt work to it. Also, since it knows how to do so many different things, I‚Äôve pretty much replaced search with it.

#### Reply 12 by u/Perfect-Campaign9551 (1 points)

Copilot has helped me quite a bit, it's pretty smart at autocompletion, giving me way less typing and allowing me to think about the problem and not every little step of how to solve it.

#### Reply 13 by u/chickentalk_ (1 points)

i disagree that the hype ¬†was making coding irrelevant

ai tooling has changed my day to day. i don‚Äôt need to google most questions, i use chatgpt instead

that is a very big deal for engineering!

### Comment 9 by u/ventur3 (25 points)

Happy to see KISS in top comment

My addition to the underrated side:

[Ubiquitous language ](https://www.agilealliance.org/glossary/ubiquitous-language/)- everyone from user, biz dev, marketing, customer support, to dev and source code, using consistent language

#### Reply 1 by u/OneTinker (11 points)

DDD has my heart.

### Comment 10 by u/shokolokobangoshey (18 points)

Underrated: SQL. The industry relies waaay too much on ORMs and devs are constantly shocked by n+1 issues, slow queries and memory hungry data retrieval APIs. Learn the fundamentals people.

### Comment 11 by u/Big-Veterinarian-823 (18 points)

Underrated: Empathy for the end-user.

#### Reply 1 by u/knightcrusader (5 points)

I'm a huge proponent for UI/UX for the end user and its saddens me how much people just don't care about usage, as long as they understand how their software works, that's fine.

### Comment 12 by u/Guilty_Serve (121 points)

Overrated:

* I'm going to be very careful with this, because I don't believe it's all over rated: Clean code/SOLID/TDD. I've seen so many damn abstraction layers masquerading as "readable code" I can't handle it. People trying to abstract popular convention in frameworks for readability drove me to insanity at a job. TDD is for when you already know what code you're writing unless you want to code yourself into a hole. It is to be said, naming conventions, searchable names, and single responsibility (within fucking reason) are good, but KISS.
* Again going to be careful here, especially since this one has been killing me a bit: specialization in a stack. You specialize in a domain where you have transferable skills, not a stack.
* Agile
* High test coverage. This depends on things as well, like are you using a framework or building something from scratch. But high test coverage makes shitty rigid code that gives you a false sense of security. In a lot of the scenarios I work in, again context dependent, I put more emphasis on integration testing than unit test every little fucking thing.

Underrated:

* Picking the fucking thing to get the fucking job done. It's absolutely wild to me that engineers can get together in a room and start solving problems you know you're not going to have or have been solved. Congrats on horizontally scaling your micro services architecture/deployment that you had hire developers to service and use K8s for all 8 of your users. The amount of times I've come across a companies that need two frontend developers using firebase to handle the business' needs is alarming.
* Not being existential enough about what you're doing. Here's your number 1 purpose: build a product that your company profits on. It's not to display your intelligence through some overly opinionated pedantic bullshit. Your code is subjectively shit to someone else. Chances are it will expire in 5 years and be someone else's hell.
* Being able to read shit code.

#### Reply 1 by u/deathamal (23 points)

I really agree with your points - a few of them I can feel in my soul.  

A good term to use for your first point of underrated is: being pragmatic. I like to tell people that term because it gives them something to call it and they can google ‚Äúpragmatic programming‚Äù and actually find material/books which talk about and explain it.

#### Reply 2 by u/NoCoolNameMatt (19 points)

I've made a career of reading, maintaining, and rewriting "garbage" code. The Developer's greatest ability is still to recognize the patterns/style of an existing codebase and then to work within it.

#### Reply 3 by u/Soejun (8 points)

Not to mention if you spend too much time trying to pick the perfect solution you inadvertently run into the issue where that perfect solution isn't actually perfect and it introduces a whole set of issues that you never even thought about before.

#### Reply 4 by u/doubleohbond (3 points)

Idk, high test coverage has saved my ass many times in my career. It may make the code rigid, but honestly I tend to think 1. that‚Äôs preferable to taking down prod and 2. can be mitigated a great deal with test structuring.

#### Reply 5 by u/Alwaysafk (3 points)

> Congrats on horizontally scaling your micro services architecture/deployment that you had hire developers to service and use K8s for all 8 of your users.

I've done this before due to corporate politics. App used by 3 people built into an over engineered monstrosity.

#### Reply 6 by u/West-Peak4381 (2 points)

Can you go into more detail about specializing in a domain?  What do you mean by domain, that sounds way better than becoming good at a stack.

#### Reply 7 by u/[deleted] (1 points)

I have seen a few people here mention Agile, what about Agile do you think is overrated?

  
Right now my team has sprints and standups to manage people but doesn't apply any agile frameworks to the project management which I think is ridiculous. I would rather less sprints and standups and more agile project management. I have recently pushed for us to deliver projects in 2 steps, after step 1 we can implement into a part of the code base where it doesn't matter a huge amount if it breaks and we can get feedback from internal teams before deploying publically. I am getting push back from managers but to me this is the the perfect example of agile project management and where it can work well (literally the last 3 releases code has been released with major bugs to customer facing parts of the code base). 

  
I think agile project management is a good thing from what I have seen.

#### Reply 8 by u/SituationSoap (1 points)

Your last underrated point is maybe at the top of my most underrated list. I've run into so many devs who think that it should take them a year or more to "get up to speed" on code bases that aren't even bad -- just mediocre -- is really troubling. 

I feel like I've seen a troubling increase over the last several years in developers who basically can't read code that they didn't write. And they don't have any tools to figure out what's going on without understanding the code. So any time that they're going to make changes, they're basically guessing about where they're putting things and what's supposed to happen. 

And these aren't people who are new to the industry, they're folks with 5 to 7 years of experience. People who should have those muscles already.

#### Reply 9 by u/seven_seacat (1 points)

Underrated: Being able to read error messages and use them to kick off debugging when things go wrong.

#### Reply 10 by u/all_beef_tacos (0 points)

This, all of this. üíØ

### Comment 13 by u/peterkneale (61 points)

Postgres is under rated.


Postgres can perform almost all json requirements including indexing and querying json properties.


Postgrs queues are absolutely fine for many small to medium sites.¬†


Mongodb is a risk now that atlas hosting is the only option. The agpl licence has forced all competitors to stop hosting it a few years back.


React is overused. It's meant for highly reactive and interactive applications like Facebook, it's use for basic forms application leads to huge maintenance issues as the react framework rapidly evolves but the app requirements remain unchanged.


Docker is the single most powerful and useful tool in the past 10 years, younger developers might not recall but having to manually install rabbit, postgres, elastic search etc and try to keep it all at the right version on everyone's machines was an awful time sink. Shared environments were awful. All solved by a plain-text docker compose file.


Docker images are the ultimate in portability, hosts compete on other features, pricing and stability.




HTMX is enough combined with a decent server side language to build enough reactivity and interactivity into the vast majority of Web applications

#### Reply 1 by u/prisencotech (18 points)

> React is overused... it's use for basic forms application leads to huge maintenance issues

React has also made people stop paying attention to how much the web has evolved. Multi-Page Apps can be GREAT nowadays. HTTP/2 and multiplexing alone is fantastic. HTMX can make things better but even without it, you can have fantastic performance without a framework at all or even any javascript.

And it continues to evolve. Look at the upcoming [View Transitions API](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API) or the proposal for [Atomic move operations](https://github.com/whatwg/dom/issues/1255) or [CSS Masonry Layouts](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_grid_layout/Masonry_layout)

You can do so much with just plain html and css already, and you're about to be able to do so much more.

#### Reply 2 by u/imnotbis (1 points)

Underrated: The AGPL licence.

#### Reply 3 by u/TsangChiGollum (1 points)

>Docker is the single most powerful and useful tool in the past 10 years, younger developers might not recall but having to manually install rabbit, postgres, elastic search etc and try to keep it all at the right version on everyone's machines was an awful time sink. Shared environments were awful. All solved by a plain-text docker compose file.

>Docker images are the ultimate in portability, hosts compete on other features, pricing and stability.

Until Docker breaks and you and your team waste a month trying to get it working again. *Shudder*. Almost quit by the end of it.

#### Reply 4 by u/spacekats84 (-1 points)

I still don't understand why the heck everyone thinks its a good idea to query json data in a database.

Storing json strings in a database to be consumed by another application, fine.

Storing json strings in a database and query the information inside them? You messed up your database design somewhere. I mean, if you want to query json, just store the whole database as one big json string then.

Edit: I'd really like someone to tell me how storing data in json inside a database keeps normal form intact, instead of, you know, downvoting me.

### Comment 14 by u/cjt09 (24 points)

I think DRY is overrated.

Yes, you should encapsulate logical units and reuse them. But that doesn‚Äôt mean duplicate code is necessarily so awful that it needs to be zealously excised wherever you see it.

I can‚Äôt count how many times I‚Äôve seen someone spend a ton of time merging together two parts of code into a singular reusable block, just to have to split it out again a few months later as requirements change and the desired functionality diverges.

#### Reply 1 by u/Venthe (-1 points)

> Every piece of knowledge must have a single, unambiguous, authoritative representation within a system

DRY is not about code duplication, but knowledge duplication. What you are describing is not DRY.

### Comment 15 by u/scientific_thinker (9 points)

Overrated:  
Agile - I am old enough to remember what it was like to develop before Agile. Most developers had their own processes which got better as we learned from each other. Granted some were worse than Agile but there were also a lot that were much better.  
Design Patterns - I think my code got better when I stopped using them. I kind of think you have to write bad code then fix it with design patterns. I don't use polymorphism anymore (I prefer composition over inheritance) so I don't need factories. Singletons were always silly. 

Underrated:  
Designing databases to 3rd normal form - The first database I worked on had an architect that designed a database like this. I have met one other developer that knew how to do this and I inherited a code base with a database designed like this. The rest of the time (about 25 years of experience), the databases I have seen have been disaster areas. Yet, the developers insist the database is "normalized". Even that Microsoft example database wasn't in 3rd normal form (and it didn't seem like they de-normalized strategically) although it was much closer than most of the databases I have seen.

#### Reply 1 by u/knightcrusader (4 points)

Normal form is a hill I will die on. I am a data organization nerd and I have to have a database set up perfectly.

Also all this JSON querying shit in databases now drives me batshit crazy.

### Comment 16 by u/HurricaneCecil (96 points)

I think TypeScript as a backend language is overrated. The front end is fine because the options are limited but if you need a strongly typed language, why not use a real one instead of a weakly typed language pretending to be one? I‚Äôm admittedly very  bad at TypeScript though which probably colors my opinion

#### Reply 1 by u/MadeWithPat (59 points)

As a consultant, a big advantage to this is operational - if I have to onboard a whole new team, it‚Äôs a lot easier for me to find a TypeScript dev than a TypeScript + {insert backend} dev.

But the entire JS/TS ecosystem is absurd, so even that has its limits when you take into account frameworks and packages.

#### Reply 2 by u/robby_arctor (6 points)

As a TypeScript dev, I don't think its strength is as a typed language. Its strength is as a better alternative to Javascript in the same part of the stack.

There are lots of weird quirks to TypeScript that feel hacky. The way that TS converts string union types into just the string type with object keys and values is one example. Implicit "any" is another.

Imho, the main advantage of TS as a backend language is less cognitive load on your engineers, and less broad ecosystem concerns. But I don't think it will ever be as effectively typed as, say, C#/.NET.

#### Reply 3 by u/moremattymattmatt (12 points)

The ecosystem can be a pain (looking at your esm/commonjs) but I really enjoyed being able to express a lot more stuff as a type and getting the compiler to validate it. You can get carried away with it though.

#### Reply 4 by u/smthamazing (9 points)

Depends on the alternative, though: my team would pick Scala over TypeScript any day, but languages like Java or C# significantly lag behind in terms of type safety and boilerplate reduction (they are getting there, but slowly).

The main advantage of TS is the ability to manipulate types. This is huge, because it allows you to create safe mappings between different types that are validated at compile time. For example, you can statically ensure that every value from a enum has a corresponding localization, and the program won't compile if some of them are missing. Or you can take a struct with optional fields and make all of them required in a unit test, so that people changing the type cannot forget to update the test, because the field will _automatically_ become required in that test. In other popular languages this often requires heavier machinery, like macros, reflection, or source generators, but in TS it's just types and type transforms.

There are some missing things in TS (e.g. nominal types are possible, but require workarounds, and type errors may get unwieldy), but its type system is becoming pretty great.

TypeScript's main problem is that it has to live on top of JS with its poor standard library, idiosyncrasies and quite spartan syntax, but at least most missing things (data structures, serialization, etc) have acceptable alternatives in the ecosystem. I think the advantages of type safety via type manipulation often outweigh the chunkiness of the underlying language.

#### Reply 5 by u/davidellis23 (0 points)

>why not use a real one instead of a weakly typed language pretending

Because typescript is succinct. Languages like python and TS are just more productive. You've got very expressive variable declarations and simple async handling.

You can run it in an interpreter to check code on the fly.

There's nothing stopping typed languages from being succinct, but they are mostly not. Golang is the most productive I've seen, but it's not as popular and it misses some nice features.

Before type hints and typescript you had to choose between static type checking and verbosity. Now you can  have both.

### Comment 17 by u/DualActiveBridgeLLC (8 points)

Similar to your underrated about presentation skills I would add to underrated 'Diagramming' and 'Nomenclature'.  Diagrams are fantastic for quick communication of the parts and interactions of the design, and the people that can make them are invaluable.  And a part of good diagrams is having solid names for the parts of the software that quickly convey what they do.

Part of Technical Interview process is to have them diagram a solution they are proposing to a hypothetical project.  The best engineers I have worked with ace that shit.

### Comment 18 by u/LaurentZw (8 points)

Overrated: CSS in JS is a performance hog. Redux, React.  
  
Underrated: DDD. Great tool to reason about application architecture

#### Reply 1 by u/External-Brilliant-7 (2 points)

idk if Redux is overrated, it's pretty much hated by lots of engineers

### Comment 19 by u/Embarrassed_Quit_450 (38 points)

Microservices are not overrated: they're misused. The point was always to enable to scale teams, so that you can have 10+ teams functioning independently from each other. The mess we have now is because people are doing microservices for the wrong reasons.

#### Reply 1 by u/lab-gone-wrong (20 points)

I don't think there has to be a difference: it's fair to say they are misused because they are overrated. People overrate microservices by thinking they solve problems that they don't, and implement them in inappropriate situations that create more problems than they solve.¬†


AI is also arguably here. It's overrated because business leaders think/want it to replace development teams when they should be focusing more on enhancing and supplementing those teams with AI.¬†¬†


AI as a developer tool is looking like an amazing & still underrated productivity driver. AI as a developer is a tremendously overrated flop for anything beyond a pitch, demo, or very basic prototyping tool.

#### Reply 2 by u/Left_Opportunity9622 (1 points)

What would be a good use-case for using microservices? And what does a bad use-case look like?

### Comment 20 by u/[deleted] (10 points)

Underrated:

TDD/Unit Tests and proper Refactoring (as in, not just moving stuff around but actually doing it in small steps as described by Martin Fowler). The metaphor I use here is from rock climbing. If you climb free solo without a rope, you can only tackle climbs that are WELL within your capabilities. And even then it's super risky and one freak rockfall or loose hold and you're dead. Now compare that to climbing with a rope and closely spaced protection (bolts etc). Since you'll now at most fall a couple feet until the rope gently catches you, you can tackle something much harder and more intimidating at the limit of your skills.

#### Reply 1 by u/alpacaMyToothbrush (13 points)

Honestly, the more experience I've gotten, the more I value integration tests over unit tests.  Orgs mandate a high amount of code coverage, and this leads devs to half-ass and write a bunch of bad tests that don't even properly test anything worthwhile and are brittle to boot.

### Comment 21 by u/ramnes (21 points)

PostgreSQL is underrated? What more do you want in terms of recognition? It literally has it all, I can't think of a more hyped database these days. On the opposite, people keep bashing MongoDB, but it's a much better database than most people think (although it's not to be put in every hand).

Anyway, my takes:

* Overrated: Functional programming ‚Äì As an Emacs user for years, I'm a big Lisp fan, but let's be honest: I wouldn't use that for a large codebase, ever. It has great ideas and properties but most languages nowadays have already borrowed all the nice bits, let's move on. :)
* Underrated: Immutable infrastructure ‚Äì I don't understand why we're still hesitant on this and why the overall tech universe hasn't massively invested in this space yet; feels like Kubernetes and cloud services came too soon with (great) abstractions that distracted us from this problem space. :(

#### Reply 1 by u/the_everloving_rex (14 points)

Exactly my thoughts on Postgres - it is the most hyped DBMS out there right now. How much more does it need to be considered properly "rated?"

#### Reply 2 by u/LaintalAy (1 points)

Functional programming is useful as it introduces a new programming paradigm to the developer. It broadens your programming skills much more than learning any other imperative language since they are all the same at the end of the day. 

Of course, I wouldn‚Äôt go for it 100% in a project either. But that doesn‚Äôt really matter.

### Comment 22 by u/Prof-Bit-Wrangler (5 points)

Totally agree with regards to Presentation and Writing skills.  I've worked with developers making over $400K TC who couldn't present if their life depended on it.  

Plus, MSA is greatly overused!

Underrated - Debugging skills.

#### Reply 1 by u/[deleted] (3 points)

> I've worked with developers making over $400K TC who couldn't present if their life depended on it.

living the dream!

### Comment 23 by u/Psychological-Leg413 (6 points)

Underrated: c# linq and efcore

### Comment 24 by u/[deleted] (27 points)

[deleted]

#### Reply 1 by u/[deleted] (21 points)

Managed Kubernetes is dead-easy to maintain. And the cool thing about Kubernetes' complexity is that you don't have to use all of the features - doing simple things with it is quite easy.

#### Reply 2 by u/VoiceEnvironmental50 (2 points)

Kubernetes is so easy to maintain  and use. If you‚Äôre having trouble with it, there‚Äôs a wealth of documentation on how to do everything for it. Sounds like you or your company has been using it wrong. Don‚Äôt get me wrong there‚Äôs a learning curve but that‚Äôs the same for everything

#### Reply 3 by u/[deleted] (2 points)

Quite the contrary. Yes if your "stuff" can run on a single instance with docker-compose - go for it.

If you actually make money from your product, you'll need at least "some" scaling, HA, observability, and dev friendliness.

At that point kubernetes is much easier than any hodgepodge of docker-compose/managed cloud solutions.  
  
And the best part is the availability of labor on the market, good luck finding a person who can hit the ground running with your snowflake hodgepodge of cloud services. With Kubernetes it's largely universal (up to a point)

I think kubernetes has done to modern infra what Linux had done to infra a while ago, we standardized on a general base layer for the infra which many people on the market have hands-on experience.

### Comment 25 by u/bony_doughnut (11 points)

Overrated: Scala

I know it's not the hottest language, but it's still widely adored even though it's good parts are mostly standardized in modern compiled languages, and its bad parts (slow compile times and verbosity) are improved, but never going to be competitive.  Time to retire it and move on. Maybe same goes for Java too, just write Kotlin

#### Reply 1 by u/anemisto (2 points)

I'm of the¬†opposite opinion--it feels like the attraction of Kotlin¬†is¬†that¬†it's not Java and¬†people¬†haven't seen Scala.


It's decidedly not without flaws--it's nigh on impossible to get more than, oh, five people writing stylistically consistent Scala, even if they're all writing idiomatic Scala.

#### Reply 2 by u/alpacaMyToothbrush (4 points)

I was trying to learn scala, and when learning a new language I like to pull down a collection library and read the code to come to grips with the language.  I pulled down scalaz, ran into the fucking 'spaceship operator' <=>.  I go on the scala irc channel and ask, oh, yeah some folks like to invent operators, that's a thing you can do in the language.  Reading further, I got an itchy feeling like I was stepping into perl world again where there *is* such a thing as too expressive.

I backed away slowly and left them to their insanity.  I haven't dealt too much with Kotlin but from everything I've read it's a very pleasant and sane language.  I was pleased to see java finally got green threads in 21.

#### Reply 3 by u/dangling-putter (1 points)

> Maybe same goes for Java too, just write Kotlin

‚ÄúEverybody knows java‚Äù ü§Æ

#### Reply 4 by u/kalalele (0 points)

Is Scala really considered verbose (don't have much exposure with the language)?

### Comment 26 by u/sime (8 points)

**Underrated:**

* Boring old proven technology and skills

**Overrated:**

* New shiny technology

The industry still has this belief that new things are always better and you have to "keep up" otherwise you will be left behind. Once you've lived long enough and gone through enough hype cycles you learn to wait and see what new things actually survive and prove themselves. The foundational concepts and skills rarely change and it is best to keep investing in those.

So, to be more specific

**Underrated:**

* Data modelling, think relational data modelling
* Understanding concurrency (it is everywhere these days)
* Transactions

**Overrated:**

* Following hype

### Comment 27 by u/uraurasecret (3 points)

Problem of KISS is people having different opinions on "Simple". My ex-colleague claims "magic" as "simple". They always make things difficult to change.

#### Reply 1 by u/knightcrusader (4 points)

Same with YAGNI... people have different places where they put that line and I butt heads with them over it.

It's a lot easier to add a couple small features to something while you are thinking about it, and in the mindset, then coming back months later to add it when you forgot how everything worked and why you did it the way you did. I can't tell you the number of times I've added something I was told wasn't needed and we ended up using it a couple months down the road. All that context switching time, saved.

### Comment 28 by u/External-Brilliant-7 (4 points)

Overrated: PR reviews.

Don't get me wrong: reviewing ideas with peers is essential. But not always through PRs, and not for all the code that is written by peers. Lots of times, we get to spend so much "focused" synchronous time reviewing low quality code that would not require a review. CI + "standards" can be fine for most usual checks.

  
PR reviews should be requested if the engineer thinks that it is required. I know that it might sound crazy ("how can he know ? what if he just bypasses it all the time ?") but it's all about tech culture, cohesion and having a sane team that matters. Whether requesting a peer to spend some time reading your code for approval or not should be IMO driven based on 1. criticity 2. scope change (the higher the scope, the more likely you'll want to have double checks by peers) 3. if you've got any doubt in your approach overall (for this, you could just ask for ad hoc advice though)

Lots of PR reviews could be avoided by 1. Hard tech rules everyone agrees on (CI helps for that) 2. Sane "moral" rules everyone agrees one (tech meetings/discussions, sometimes informal, help for that) 3. Management giving value & recognizing high code quality (this is not the case in 95% of companies I've been in unfortunately, tech culture is low in most of companies)

  
Underrated: code duplication. Sometimes, it's very good to duplicate code.

### Comment 29 by u/MargretTatchersParty (19 points)

Underrated:  
 Postgres extensions and newer features- There is a lot of detail here that could help your architecture. Additonally there are extensions in PG that would allow for it to compete with other databases. Unfortunately these exenstions are second class citizens.

  
Version verfication and updating tools - This is the redheaded 

Data pipelines and a lazy approach to handling data processing: Stop relying on a service calling another service calling another service in realtime. Acknowledge that it takes time to process data, and acknowledge that the screen may be representing old data, or data in motion.

Appropriately rated: 

Mongo- It's had it's faults, and has gotten better. It's there because it has a decent query engine on top of being a key value store.

Observability: It's greaat to see distributed tracing. However, given the vendor selling stuff I think this has a high risk of abuse.

Overrated: 

Microservice architecture- There are strong limitations of what you should ask a microservice for. Many of these services you would be better served by a library. (I.e. a zip code service) and automated version updating CI/CD tools

Monorepos- I get it managing a lot of internal versions are difficult. But letting anyone jump accross huge code bases for fun is bad. Also managing the seperate builds for every module inside of the monorepo is pretty terrible.

OOP- its a bit tiresome to represent functionality connected to the classes and objects themselves. 

AWS vendor services- Making fixed vendor products has always been a bad thing. Why we're pretending like the old bad thing is new good now, is blowing my mind.

Developer Adovcates - One of the reasons I dropped twitter. I'm tired of seeing salesmen posing as developer friendly people and the context of what they do is basically POCs claiming it'll solve your problem. They're not your friends.

#### Reply 1 by u/Shnorkylutyun (3 points)

Regarding monorepos, how do you deal with atomic changes like api changes which affect multiple projects?

#### Reply 2 by u/Embarrassed_Quit_450 (1 points)

I was torn between downvoting for dev advocates and upvoting for OOP. OOP was a good idea because of messaging and we decided to keep only the bad bits.

Dev advocates, well there are bad apples but it's unfair to say they all are.

### Comment 30 by u/yojimbo_beta (28 points)

I'm only going to talk about underrated technology. I want to keep things positive


_Underrated language_ JavaScript. Yes, JavaScript. It's easy to learn, it's fast, it has bags of features, and the type coercion problems largely go away by simply using a static superset like TS or Flow. Some of the dependencies are badly managed but this is gradually getting better.


_Underrated language 2_ Java. It has gotten so much better than the Java 7 days! Now Java has pattern matching, type inference, records. And the ecosystem / tooling is superb.



_Underrated technology_ SQLite. Since discovering it I have found so many use cases for it. Any single user process that needs a moderately complex data storage can leverage SQLite. You can use ORMs or do plain queries, you can distribute data as plain files, you can hack it to act like a local graph storage engine. It is wonderful for prototyping.


_Underrated technique_ ports and adapters. Since really internalising the distinction between IO code adapters, port interfaces and pure domain functions, my projects have become more expressive, faster moving and easier to navigate.

#### Reply 1 by u/comatosesperrow (7 points)

Could you give a quick summary on your last point?

#### Reply 2 by u/Drevicar (5 points)

Sqlite scales in production up to several thousand concurrent users pretty easily as well.

#### Reply 3 by u/Necessary_Air4916 (10 points)

JS can hardly be underrated, given that it's basically the only language supported by browsers. On the backend I don't see much reason to use it over alternatives.

#### Reply 4 by u/IXISIXI (2 points)

Strongly agree on JS being underrated. You make a lot of tradeoffs, but it's really easy to do a lot of powerful things with JS, and it's very easy to learn.

#### Reply 5 by u/incredulitor (2 points)

I appreciate the positivity and I'll add: I don't think I've ever heard anyone bag on SQLite who's used it.  It could still be underrated as far as people not realizing it's there as an option in cases where it would help.  It doesn't solve every problem, but it's also a way better product for not trying to.

#### Reply 6 by u/Gwolf4 (1 points)

> Underrated technique ports and adapters. Since really internalising the distinction between IO code adapters, port interfaces and pure domain functions, my projects have become more expressive, faster moving and easier to navigate.

Examples or blogpost for your inspiration please?

#### Reply 7 by u/jacove (1 points)

It took me scrolling for 10 minutes to find SQLite mentioned. It‚Äôs amazingly powerful!

#### Reply 8 by u/80eightydegrees (1 points)

Fast compared to Ruby, Python and other interpreted languages? Yes

Compared to C#, Java, Go? I wouldn‚Äôt call it a fast language

#### Reply 9 by u/camblanks (1 points)

Love javascript. Our entire infrastructure is built with it cause azure loves some JSON and JS plays well with the cloud tools

### Comment 31 by u/Baldy5421 (3 points)

Overrated: Any cross platform framework for mobile. Flutter and RN should go die in a ditch.

### Comment 32 by u/Lfaruqui (3 points)

Underrated: Test harnesses, you‚Äôd be surprised how many people don‚Äôt write them!

### Comment 33 by u/GrumpyOldTimerDev (3 points)

Overrated:

* Microservices: For the "if you don't do microservices you are doing it wrong" vibe.
* Libraries: I'm not talking about "frameworks", i'm talking about importing a 200+ functions library to then use 1 or 2. I've worked on projects where the list of dependencies was insane. I understand the "don't reinvent the wheel" principle but I feel the usage of libraries is a bit out of control.

Underrated:

* Monolith: I think it's a great option for first version of a new product (like an MVP). Once you gather info about real usage, you can think of how to scale where needed. Don't overcomplicate your design at the beginning.
* Waterfall. I'm serious. Best managed project I ever worked on was waterfall. No one moved a finger until the previous phase was signed off. Documents were perfectly clear and development was so smooth I still remember it.

### Comment 34 by u/hippydipster (3 points)

Overrated:
   
Using the "best" tool for the job.

People suffocate themselves sometimes trying to always choose "the best" tool.  What's the best database.  What's the best programming language.  What's the best ORM.  What's the best continuous integration platform.  What's the best GUI framework.  What's the best web framework.  What's the best serverless language.  etc etc etc. 

But these days, there are so many perfectly adequate choices, it's really not useful to tie yourselves in knots choosing the best.  If it's good enough (and most are) and you *LIKE* it, then it's the best.

Underrated:  

Saying no to a dependency.  We should say no to additional dependencies more readily.  Instead we say "sure, why not?"

### Comment 35 by u/David_AnkiDroid (3 points)

Underrated:

* Maintaining git history throughout a complex refactor

### Comment 36 by u/Stephonovich (9 points)

**Overrated:**

Full Stack Engineering. At best, you know FE and BE. You are not an expert at the DB layer, nor the network layer, nor the storage layer, etc.

Postgres. Hear me out (as a DBRE). It's good enough for most uses, and that can make it a dangerous choice. It is, at its heart, still a relational database. Can it be used as a document store? Sure, but it's not optimized for that, and querying and indexing JSON[B] is fraught with peril. Can it be used as a queue? Of course, but at some scale you'll find out what a huge amount of writes do to Postgres. The problem as I see it is that a company will have Full Stack devs who default to "just use Postgres" without understanding its quirks, and this works fine up until it doesn't. At that point, they'll probably shrug and upsize the hardware. Rinse and repeat. By the time it's gotten _really_ bad, fixing the problems becomes a nightmare.

UUIDs. I swear to $DEITY, if the only thing I accomplish in my entire career is to dissuade devs from using UUIDs when an integer would work fine, I'll die happy. They're horrible for performance in every RDBMS, for different reasons. The k-sortable varieties like UUIDv7 are less horrible, but it's still at best a 16-byte value, which is double the size of even a BIGINT. Please stop.

Serverless. What an amazing grift by Vercel et al. Honestly, I commend their ability to siphon money from everyone. Hosting a web app is not nearly as complicated as it's made out to be, and almost certainly does not require K8s.

Cloud Anything. It's very convenient, yes. It's also set back computing skills by an absurd amount, by which I mean that your average applicant for any kind of Ops-adjacent role is unlikely to actually know how to administer or troubleshoot Linux.

**Underrated:**

MySQL. It suffers many of the same problems as Postgres (worse for some) WRT using it as a non-RDBMS solution, but it is quite a bit faster for certain applications, and can scale just fine.

Knowing How Shit Works. What is K8s? A container orchestration system. Cool, what are containers? Oh, they use cgroups? What's that? What's CFS? Etc.

#### Reply 1 by u/Crafty-Pool7864 (3 points)

I feel you on UUIDs. I‚Äôm responsible for them in a 10 year old code base and truly hate my past self.

#### Reply 2 by u/seven_seacat (2 points)

I agree on UUIDs so much. But we must hide numerical IDs from the user interface! ...for some reason...

I'm one of those full-stack devs that is like "just use PostgreSQL!" though :D

#### Reply 3 by u/spacekats84 (1 points)

> Full Stack Engineering. At best, you know FE and BE. You are not an expert at the DB layer, nor the network layer, nor the storage layer, etc. 

More than likely that's true. But there are some out there that do understand all that and are probably getting super underpaid for the value they bring to their team because they're the only one that understands what is going on when things go wrong.

It's not like I know from experience or anything.

### Comment 37 by u/SpiderHack (5 points)

Underrated: software design patterns, and then architectural design patterns.

Why I say this: cause most people don't actually take the time to learn them well enough. Then they get a surface level understanding and don't understand their benefit in communication, documentation, decoupling, etc. then they ober use them in the wrong places and ways.

The way I tell my students to look at patterns (design & arch) are that they are tools in your tool belt. Sure you CAN use a wrench and a drill as a hammer, but you'll get cleaner and easier results if you use a hammer, and inversely using a hammer when you need a screwdriver will just as equally if not more mess things up.

Learning them and then actually learning them well enough to be efficient in their selection and use is what separates a programmer from a software engineer IMHO.

### Comment 38 by u/_BearsEatBeets__ (6 points)

Overrated: Object Oriented Programming

It is simply not useful in real world projects. Company wants to add a new feature and you have to massively refactor. Company wants to pivot? Huge refactor

Simple functions and Classes here and there that do the job are much more real world friendly and changeable. Plus you don‚Äôt have to forecast the future of the company on Day 1.

### Comment 39 by u/engineered_academic (10 points)

Generative AI. Hot take here I know but its essentially the new blockchain. Everyone's gonna play around with it and make a shit ton of money selling it. Then it will go away.

#### Reply 1 by u/[deleted] (7 points)

[deleted]

#### Reply 2 by u/alpacaMyToothbrush (2 points)

> Then it will go away.

Somewhere between takes like this, and /r/singularity breathlessly predicting the dawn of AGI, lies the truth.  No, AI isn't going to 'take our jobs' any time soon, but it will make just about everyone more productive, esp the sr folks that can spot the hallucinations and not just blindly trust the output.

#### Reply 3 by u/[deleted] (0 points)

[deleted]

### Comment 40 by u/SithLordKanyeWest (2 points)

My hot take would be the cloud is overrated, AWS, Azure, etc. A lot of the ideas of cloud development come from a zero interest rate environment, of growth at all costs, devs need to focus on only the product. Surprise unit economics matter, and we should be looking at how to lower costs too, starting with the cloud costs.

### Comment 41 by u/FailedGradAdmissions (2 points)

Underrated? COBOL yes, the language and tech itself is obsolete. But I personally know several COBOL debs making 200k with better than average WLB and an unmatched job stability.

Java is also there and I imagine would be in a similar position 20-30 years from now.

### Comment 42 by u/deepak483 (2 points)

Underrated to me doing end of the day log with light retrospection and write down your ideas and thoughts before the first line of code.

### Comment 43 by u/[deleted] (2 points)

GraphQl federation is overrated, so annoying to work with

#### Reply 1 by u/copyAndPasteEngineer (2 points)

What made it annoying to work with?

### Comment 44 by u/maclirr (2 points)

Do you recommend any good foundational learning material for postgresql for someone coming from the mysql world? I'm finding the official documentation a bit too much.

#### Reply 1 by u/dondraper36 (3 points)

The Art of Postgresql book is superb. The author, IIRC, is w PG contributor himself so he definitely knows the subject very well.¬†


That said, this book often refers to specific section of the documentation. This is accompanied though by comments and clarifications so if you find the documentation too dry, you might really like the book.

### Comment 45 by u/evalir (2 points)

Overrated:

- Uncle bob's books. I'm sorry, but unless you're doing hardcore Java enterprise work, they're probably not great. And frankly, for those that do heavy enterprise the common complaint is that these systems are overly complicated to understand due to all the patterns used. The discipline it instills is good, but it shouldn't mean being a hardliner on patterns even if it makes code more complicated.

- React: The react core team should have more opinions on how it is used instead of advertising as a library. The result has been a "library" which always becomes an unmanageable mess of a codebase unless there's someone keeping everyone in line.

Underrated:

- Computer Architecture / Hardware knowledge: Tbh my whole understanding of programming changed when I went through "Computer Systems: A programmer's persective". I knew many of these things but definitely not put together so eloquently.

- CI/CD: in this day and age pls people its easy to set up a simple ci job in github.

- Focus on performance: This feels like its shifting, but it's incredible how people just disregard performance. The result is extremely slow & annoying software down the line. Being more performant is always good, and there are no premature optimizations, just bad prioritization.

#### Reply 1 by u/incredulitor (2 points)

Appreciate all of the perspectives, just a bit from the other side on comparch, hardware and performance: I've made a career (until I didn't) on vertical scaling with low-level C, C++, assembly and tuning to available hardware.  If it's not obvious, it's easy for me to wish that typical web apps were more responsive, that browsers and JS didn't take so much RAM and so on.  At the same time, I've probably worked too hard to go against the grain and stick to my low-level focus while horizontal scaling and distributed systems were picking up as rich and interesting areas.

As I'm trying to get back into it and find a good new niche that doesn't totally throw out my old skills, ScyllaDB (Cassandra replacement written in C++) and Redpanda (Kafka replacement in C++) are targeting tail latency and cloud costs rather than average latency, throughput or other metrics.  They seem to make a clear case, and at the same time are both small startups that don't appear to be shifting the whole direction of the industry - yet?

Somewhere during the 2000s and 2010s, as much as C++ has been my bread and butter, I also feel that it was at times a premature optimization to be using it at all.  Clearly for core services like Scylla and Redpanda are providing, performance (and predictability!) do matter.  I haven't yet seen similar analyses though on whether, for example, GC pauses or just general language and runtime overhead are as big of a deal for frontend or midlayer packages like React, Node or Django as they've turned out to be for data infrastructure.  My sense is that it probably wasn't as much of an issue when LAMP stacks and Rails were the big thing due to web apps just generally not being as complex or having as big of a userbase.  Curious if you've got any perspectives on that.

### Comment 46 by u/agumonkey (2 points)

underrated: experience in migrating whatever: software, database, models.

### Comment 47 by u/Ecksters (2 points)

>Also, the popular argument of "now we can swap the database every day" is so unrealistic in my opinion. I don't really remember ever needing to unexpectedly swap a database. Maybe, I'm wrong.

Probably because you've been using Postgres instead of MongoDB üòÅ

### Comment 48 by u/Aware_Atmosphere4401 (2 points)

**Overrated:**

1. **Microservices:** Often add unnecessary complexity for smaller projects. The hype has overshadowed the simpler alternatives that might be more efficient‚Äã
2. **MongoDB:** While flexible, many overlook the robustness of PostgreSQL, which can handle similar use cases more reliably with features like JSONB columns‚Äã 
3. **Clean/Hexagonal Architecture:** Good principles, but strict adherence can lead to over-engineering and unnecessary complexity‚Äã

**Underrated:**

1. **PostgreSQL:** Highly versatile with advanced features like `FOR UPDATE SKIP LOCKED` for task queues, yet underutilized by many developers‚Äã 
2. **Presentation/Writing Skills:** Crucial for effective communication and career growth, yet often overlooked in technical fields
3. **Regularly Deleting Unused Software/Infrastructure:** Helps prevent technical debt, reduce costs, and simplify maintenance‚Äã

### Comment 49 by u/notdelet (2 points)

From a technical perspective, I'd say that constraint and/or linear programming solvers are very underrated. They are like a magic bullet for the occasional situations when they are appropriate to use.

### Comment 50 by u/lenzo1337 (2 points)

Docker, AWS/GCP and rust.

At some point they create more problems then they solve. Actually scratch that, they usually create more problems then they solve.

### Comment 51 by u/jjirsa (2 points)

Cassandra.

Most teams should use it for most tasks. Measurably better availability than relational, true proper HA cross-DC, actively developed and deployed by multiple FAANG companies. 

Has fallen into the category of "well understood boring tech" for most people, but it runs a huge chunk of the world.

(And you're probably going to shard and denormalize anyway once you're in production and have real traffic, so just use a database that forces you to denormalize in advance and allows for 100x fewer shards)

### Comment 52 by u/Throwaway__shmoe (2 points)

100% MongoDB. Bane of my existence. Should‚Äôve just went with a relational database.

### Comment 53 by u/No-Vast-6340 (2 points)

Under rated: Test Driven Development

### Comment 54 by u/Delphicon (2 points)

Underrated: Feature Creep

Tech still doesn‚Äôt scale well. You can only realistically maintain X number of features in a codebase.

If a companies tries to stuff too many features in they will fail and the project will get stuck.

There are ways to change your ‚Äúfeature capacity‚Äù but they‚Äôre highly technical. Capacity isn‚Äôt something that is solved by throwing bodies at the problem.

### Comment 55 by u/[deleted] (2 points)

Agile/Scrum way overrated.

### Comment 56 by u/JaneGoodallVS (2 points)

Rails is underrated, and I agree with most of the common criticisms.

It's so easy to get shit done.

### Comment 57 by u/Effective_Rain_5144 (2 points)

Overrated: SAP ecosystem, Power Platform
Underrated: Excel, C#

#### Reply 1 by u/Schmiddi-75 (2 points)

How dare you to say that Microsoft Excel is underrated! Please elaborate.

### Comment 58 by u/vinnymcapplesauce (4 points)

IMHO, it's underrated how much you can get done with just nginx, PHP, Vanilla JS, and MySQL. Add Redis in there FTW.

Everything else is overrated.

### Comment 59 by u/freekayZekey (2 points)

overrated:

ai tooling. i think devs would be better served if they sat down and thought about their code more than typing away. typing out code isn‚Äôt the bottleneck, and i don‚Äôt understand people obsession with line output. 

before you ask: yes, i‚Äôve tried copilot. yes, i‚Äôve used ai tools in intellij. no, i do not find them particularly effective. one soundboard is a coworker; they‚Äôll have to deal with my code. another soundboard is pen and paper. last soundboard is tdd. no, i think learning new tech from a potentially unreliable source instead of docs isn‚Äôt a good idea

nullable types. they‚Äôre convenient, but i feel like people overstated their usefulness. rarely encounter null pointer exceptions when i work with languages without nullable types. they‚Äôre mostly avoidable if devs thought for a second. 

underrated:

jvm. well, not underrated, but maybe under appreciated? java‚Äôs been around since i was born (man, i‚Äôm old‚Ä¶) and still going. it‚Äôs impressive. 

postgresql. can‚Äôt rave about it enough 

asking questions. i‚Äôve met plenty of devs who rather assume things instead of asking for clarification. you‚Äôre not dumb for asking questions; be an adult and deal with the awkwardness of asking a question.

basic science. devs are smart, but are awful scientists ‚Äúline go up‚Äù and ‚Äúline go down‚Äù aren‚Äôt good measurements

### Comment 60 by u/[deleted] (4 points)

Tech: NodeJS on both FE and BE. It‚Äôs a terrible language for your backend. 

Idea: Clean code and anything from Uncle Bob.

#### Reply 1 by u/knightcrusader (3 points)

> It‚Äôs a terrible language for your backend. 

Ha I just had this rant with a friend this past weekend. Glad he also agreed.

### Comment 61 by u/gardenfiendla8 (2 points)

Underrated: Naming things

Naming things is 99% of software development and it is given a criminally low amount of thought in my experience.  Good names create proper indirection and abstractions, communicate and justify the existence of variables and procedures, and will extend the longevity of any codebase.  I've only read a handful of books that even devote a chapter to good naming conversations. And none of them were academic, which is sad because a lot of guidelines could be borrowed from the field of philosophy.

Overrated: anything that doesn't let you bend its rules a little bit

### Comment 62 by u/winnie_the_slayer (2 points)

Overrated:  the idea that human consciousness is some grandiose super powerful process, devs should be rockstars who always get it right.  Human consciousness is a very weak process (sitting on a mountain of unconscious processes).  People make mistakes.  They do dumb things.  We would all be better off if we accepted some humility.  Recognize that humans have limited power and screw up a lot, and design development processes around that.  Some teams do this better than others. This applies to stuff like avoiding  managerial time management, (meetings throughout the day with 30 minute breaks), using Team Topologies' idea of focusing a team on a small bit of tech, and overall scaling down the expectations of engineers.  This would probably mean less pay per employee, but more employees, and less stress per person.  

Management tends to be the one fucking this up most often, but there are still a lot of devs who believe in rockstar culture, blaming people, all that.


Also overrated: text-supremacy.  Programming languages using only text.  Devs who think guis are for lazy wimps and insist everyone memorize keyboard commands for emacs/vim/intellij and use only CLI tools.  There are graphical programming languages that have inherent advantages in stuff like parallelism.  Some people think in graphical/visual terms much better than text, and their approach to problem solving is very different than the textualists.  Using a mouse and gui is not inferior.

### Comment 63 by u/[deleted] (1 points)

MongoDB has its use cases. It‚Äôs just that they‚Äôre not very common. If you need to read/write json to a database you probably should use Postgres. If you need to scale up read or write throughout beyond the capacity of a single machine you should probably use MongoDB. It‚Äôs just that very few projects have this requirement.

### Comment 64 by u/[deleted] (1 points)

Sqlite is underrated. If you‚Äôre embedded or making some local-only app and you ever roll your own data file format, you probably should have just used sqlite. ¬†

ETA: Admittedly my embedded devices are comparable to an underpowered laptop. Sometimes you can‚Äôt fit a whole ass sql library in your system, understandable.

### Comment 65 by u/Aromatic_Heart_8185 (1 points)

Massively overrated: DDD aggregates.the transactional boundary is an arbitrary definition that will be defined because reasons other than business, eg database limitations.

### Comment 66 by u/Laicbeias (1 points)

ive seen the best practices for nodejs homepage. i asked if thats best.. what is worst

### Comment 67 by u/chickentalk_ (1 points)

overrated: DRY

repeating yourself is fine or encouraged when you aren‚Äôt yet clear on an appropriate longer term abstraction

### Comment 68 by u/lollaser (0 points)

Overrated: JS for backend, AI Tooling, Low-Code, Design Patterns / Principles, SaaS, Cloud   
Underrated: PHP for backend, Monoliths, Raw SQL, simple code instead of magic

### Comment 69 by u/miyakohouou (1 points)

Underrated: Having a very strong grasp of the fundamentals

Overrated: Frameworks and design patterns

#### Reply 1 by u/dondraper36 (2 points)

I don't know why you were downvoted. I agree 100% that learning the fundamentals once opens mental doors. This is why I started reading books on computer networking and operating myself to fix/update the fragmented knowledge.¬† Design patterns, as was written in one of the comments too, are to a certain extents historical ways to overcome the limitations in Java and C++. A lot of them are not even required in the more modern programming language. Some of them are even anti-patterns like in Go.

### Comment 70 by u/chrisza4 (1 points)

Overrated: 

IOC container. 

It is a technique to workaround limitation of Java and C# which block ability to do unit test. And somehow people from this two languages try to introduce IoC container everywhere they go.

Configurable app:

Many time people are asking of configurable app because they just don‚Äôt want to spend time thinking about which setting is appropriate. I swear there are more than thousands options that user would never configure to use. And configuration file now required hundred pages of manual.
Please, stop using configuration as a solution for ‚ÄúI don‚Äôt want to think about it‚Äù. 

Underrates

Beam VM, Erlang and Elixir. This is super cool ecosystem and tech for doing large scale application but rarely being used.

Lisp dialect. It does really make you think in different way and become better programmer.

### Comment 71 by u/dinfarfar (1 points)

Underrated: TDD.

I was at one point camp TDD is stupid. "Oh you are coupling implementation with tests", "oh you are wasting time", "oh you don't know what to test until you've built it" etc. etc. But after working in teams with really great TDD(and XP) practices I will never again write software in any other way.

Yes yes, it's a cult. No I cannot give any good examples on why it's so great. It just sparks me with joy.

#### Reply 1 by u/miyakohouou (3 points)

> But after working in teams with really great TDD(and XP) practices I will never again write software in any other way.

I worked on a team that was fanatically devoted to TDD and were among the most skilled group of people I've worked with when it came to doing TDD correctly, and I walked away from that experience vowing to never to TDD again because I think it's just a really bad idea. It's interesting how people can have two such starkly different conclusions from similar experiences.

#### Reply 2 by u/dondraper36 (1 points)

Thanks! Any resources on TDD you can recommend?

#### Reply 3 by u/_enochian_ (1 points)

Do you see it work for web development or it's better suited for backend? I'm a FE developer that only read about TDD, and I can't see it working on the FE.

### Comment 72 by u/mrequenes (1 points)

Overrated: using open source libraries for trivial tasks; e.g., something you could do with less than 40 lines of code.

### Comment 73 by u/StorKirken (-3 points)

I‚Äôve always felt that *dependency injection* as a technique is overrated, especially once it‚Äôs done early. The indirection means code that is much more difficult to understand and evolve, and I‚Äôve seen it cause a lot of errors. 

Typed languages help with this, but still leads to a lot of boilerplate, so if a problem can be solved without dependency injection it‚Äôs worth checking out that variant first.

#### Reply 1 by u/WhatsHeAt (8 points)

I think I can agree in the early stages of an application's development, trying to divide up your functionality into injectable services can be a bit time consuming and possibly a waste of time as domain boundaries become more concrete and things need to be refactored.

For a larger project though, I can't imagine writing unit tests without dependency injection. Lets you mock all the domains that don't have anything to do with the feature you're testing, and resulting tests end up small and maintainable.

#### Reply 2 by u/Rough_Acanthaceae_29 (5 points)

Have you ever written a test for something not trivial?

#### Reply 3 by u/protomatterman (2 points)

It can be ok but I've seen to just be overused and become too abstract. That's true of a lot of things but it seems too easy to misuse. My experience was having to figure out how a Spring service was calculating some metric. It was quite complex due to the high number of classes used and lot of autowiring going on.

#### Reply 4 by u/the_everloving_rex (1 points)

You can't get away without managing dependencies, you are doing it one way or another. DI containers are the worst solution to this problem -- except for all the others.

#### Reply 5 by u/[deleted] (1 points)

[deleted]

#### Reply 6 by u/ReginaldDouchely (1 points)

Agreed.  If I was allowed to 'cheat' and override the implementation of concrete types (like mocking an interface, without needing an interface) JUST for test purposes, then I wouldn't need to deal with a pile of extra interfaces that only ever get one implementation, or the would-be-build-errors that are now runtime errors because of DI containers.


Of course some dipshit devs would misuse overriding concrete types, but I don't think it's any more of a foot-gun than most other things devs can do.

### Comment 74 by u/phaser1299 (0 points)

# Underrated

**Negotiation / project management skills** - so often (especially with junior developers, but even seniors do this) I'll see folks assume a spec, design, or requirement doc is finalized and cannot be changed. The developers that question impractical parts of the project and propose reasonable alternatives seem to have such a big impact in the long run. Designs, PMs, and other stakeholders mean well, but don't have the technical context engineers do. Next level: helping other developers move their projects along, while negotiating with stakeholders.

# Overrated

**Progressive web apps (PWAs)** - while I think they have their place, I've worked on teams that thought these were a good idea, and overall they are extremely limiting. The tooling just isn't there yet. Every PM / designer wants to add $X, but because you built a PWA instead of a native app, it's impossible. And cost wise, with hybrid frameworks, I'm not even sure they are that much less expensive. It's great that you don't have to bow to down and do a little dance to appease the app store gods each time you'd like to release, but besides that I don't see the point. Most users have no clue how they work. I want to like them, but they just seem like a mistake in the vast majority of cases

### Comment 75 by u/Fit_Ad3500 (0 points)

Typecript is way overrated.

Especially when developing new apps from scratch.

### Comment 76 by u/[deleted] (0 points)

[deleted]

#### Reply 1 by u/miyakohouou (0 points)

The syntax might be less readable, but there's a benefit to the fact that they are expressions rather than statements.

### Comment 77 by u/Ambitious-Product-81 (-3 points)

In my opinion, 

Overrated
1. Agile 

2. Microservices (for me; microservices does not solve a engineering problem instead solves a organisational issue i.e 1000 engineers working on a same code split in different teams, thats where microservices shines) 

3. Retro (In my experience, Retros are pretty useless; to improve is often ignored by the team due to burden of tickets) 

4. Cloud (Vendor lock in, cold starts, egress charges etc etc except cloudflare) 

5. Nextjs or perhaps vercel (Extremely bloated right now)

6. Elastic search ( Why the fuck do i have write such complex code for a simple problem alternatives like meilisearch etc provides a much more simpler way) 

7. Optimisations especially Premature optimisation. 

8. Clean Code (I never seen one) but code should be well tested.

9. Measuring our ego by our editors and operating system. 

8. Tech Influencers working in FANG/Shopify that gives advice on Linkedin. 

9. Hiring managers (Why do we need them when engineering managers are available) 

10. Open source (xz utils etc) Critical software should be closed source imo 



underrated

1. ERD (Engineering requirement diagram) 

2. sqlite/postgres (ton of extensions, documentation of SQlite is chef‚Äôs kiss, For update to avoid deadlock etc)

3. STAR communication (Developers myself included; really need to compose our communication as a form of story) 

4.Quote from the movie - Steve Jobs ‚ÄúYou can be decent and gifted at the same time‚Äù. Actually encapsulates what we should strive for. 

5. Distributed Tracing (OTEL). Don‚Äôt need to use any fancy tech like jeager etc  

6.  I HATE when we argue which language or framework is better than the other. We should be focused more on the Results instead. I don‚Äôt care if you use PHP with jquery for an app that results in > 25K MRR. Use whatever technology that suits best in a given situation.

### Comment 78 by u/[deleted] (0 points)

Overrated: Kubernetes
Underrated: AI


I know some people in software think AI is a fad or stupid and is already overhyped, but the reality is "AI" is going to change everything about computing for most consumers/users.

### Comment 79 by u/[deleted] (-5 points)

[removed]

#### Reply 1 by u/alpacaMyToothbrush (3 points)

Found the dynamic typing evangelist

### Comment 80 by u/dacydergoth (-7 points)

Every programmer should:

Know an assembly language (68000, ARM, RISC-V, SPARC, x84 if they're masochistic)

Have written a small CPU in Verilog and run it on an FPGA

Have written a basic OS with at least paged MMU capabilities 

Have implemented a network protocol 

Have implemented a file system 

Have written a VM with a bytecode and garbage collection 

Understand queues

About 80% of our production issues would go away if devs understood these things

#### Reply 1 by u/papawish (1 points)

I mean, I too learnt those things, felt incredible, and am a better engineer because of it. 

But expecting everyone to have done this is idealist. 

  
Even grads from CMU, the best CS uni in the world, don't get to implement all this. They are taught about it, they have small labs to implement small things, but not the whole damn things lol.

#### Reply 2 by u/alpacaMyToothbrush (1 points)

I mean these are all fun cs projects;  My ASM class was one of my favorite classes in college, but I seriously doubt they'd have any impact on bugs in production.

Want to reduce bugs in production?  Teach your devs how to **TEST** their code.  I'm not talking stupid unit tests that assert result != null, I'm talking about the whole mindset of covering your valid inputs, your expected outputs, your happy and sad paths.

Bugs in prod are a result of lazy testing, not a misunderstanding of low level OS details.

### Comment 81 by u/[deleted] (-2 points)

I might be totally wrong, but I think microservices are not bad or overrated. It's simply beacuse they are sometimes used at the wrong place. So basically in this situation the benefits aren't as noticeable as they should be, which may make them seem overrated.

#### Reply 1 by u/AndyWatt83 (2 points)

There's hardly any bad ideas in programming that go 'mainstream'. There's loads of things that are used in the wrong place or context, and the people that experience those situations without really understanding the context call them 'bad', rather than misplaced. 

Microservices are amazing, in a really small set of use cases. Unfortunately, they are absolutely everywhere as an almost default option, so almost everyone who encounters a microservice has an absolute mare. 

Overused by about 1000000%, but not overrated, is how I would describe microservices.

### Comment 82 by u/OblongAndKneeless (-4 points)

"Algorithms".  There are college courses that teach (a known subset of) algorithms...but what's their practical use? Technically, everything is an algorithm. Why learn something that you'll never use?

### Comment 83 by u/ategnatos (-11 points)

Overrated:

Postgresql

Presentation/writing skills

Underrated:

Microservices

MongoDB

Clean/hexagonal architecture

