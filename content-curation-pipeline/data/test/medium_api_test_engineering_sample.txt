Create an Infinite Animation With Vanilla Javascript

In my previous blog post, I showed how to perform simple sound detection. I used requestAnimationFrame for visualization. I even went a step further and created my own React library for drawing graphs. First, I'd like to give a quick recap and reintroduce some of the basics.

What is requestAnimationFrame?

In JavaScript, you can easily create animations using requestAnimationFrame, a feature of the Window API. It has been supported by modern browsers since 2023. With this function, you can make animation calls by providing a callback function. One thing to note is that if the screen is changed or hidden, the animation may pause due to browser optimization. The goal is to ensure efficient use of the user's resources.

A Basic Animation By Using Canvas API

This application consists of a simple animation including a house, a car, and a tree. First, we set up the basic HTML structure.















Hello













































I represented each object (such as the house, car, and tree) as a separate object in code, and handled their rendering using update and draw functions.

How to create an animation loop by using the Canvas API?

In this section, we move on to the animation part - where each object is rendered on the screen in a loop. This is the core rendering logic that makes the scene dynamic and interactive.

const canvas = document.getElementById("canvas");

if (canvas.getContext) {
  const ctx = canvas.getContext("2d");

  const road = new Road();
  const car = new Car();
  const sky = new Sky();

  const greenTerrain = new GreenTerrain();

  function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }

  tree = new Image();
  house = new Image();

  const animate = (time) => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    greenTerrain.update(ctx.canvas.width);

    sky.draw(ctx);
    greenTerrain.draw(ctx);

    road.draw(ctx, time);
    car.draw(ctx);

    window.requestAnimationFrame(animate);
  };

  Promise.all([
    loadImage("./assets/tree.png"),
    loadImage("./assets/house.png"),
  ]).then(([tree, house]) => {
    Assets.treeImage = tree;
    Assets.houseImage = house;
    window.requestAnimationFrame(animate);
  });
}

This is where our animation loop begins - all objects are continuously redrawn to create motion.
Before starting the loop, we need to load all the assets.
For this, I used a Promise-based structure to ensure everything is ready before rendering starts.

Personally, I prefer object-oriented coding because it keeps things clean, understandable, and easy to manage.

Drawing Road to Canvas

In this part, I used the animation time to create a sense of movement.
Thanks to this approach, it gives the illusion that the car is actually moving forward on the road.

class Road {
  draw(ctx, time) {
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = "gray";
    ctx.rect(0, 350, 500, 50);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.lineDashOffset = Math.round(time / 10);
    ctx.strokeStyle = "white";
    ctx.setLineDash([20, 20]);
    ctx.lineWidth = 1;
    LineDrawer.draw(ctx, 0, 375, 500, 375);
    ctx.restore();

    ctx.save();
    ctx.lineWidth = 0.5;
    LineDrawer.draw(ctx, 0, 350, 500, 350);
    ctx.lineWidth = 10;
    LineDrawer.draw(ctx, 0, 400, 500, 400);
    ctx.restore();
  }
}

Other Drawings

In addition to the road, I created a simple car object. The car itself remains stationary, but by animating the road, it gives the illusion that the car is moving forward. This technique enhances the sense of motion without actually moving the car object.

While I used basic shapes for the car, incorporating an image could have provided a more polished appearance.

Moreover, although it might not be evident in the image above, there's also a smoke animation included. This subtle effect adds realism to the scene.

I integrated a simple sky object into the animation.

class Sky{
    draw(ctx){
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle="skyblue";
        ctx.moveTo(0,100);
        ctx.lineTo(0,0);
        ctx.lineTo(500,0);
        ctx.lineTo(500,100);
        ctx.fill();
        ctx.restore();
    }
}

I generated the positions of the trees randomly in the image. There are 1000 trees in total. If any tree goes outside the screen, its position is recalculated randomly.

class GreenTerrain {
  constructor() {
    this.trees = [...Array(1000).keys()].map(() => new Tree());
    this.house = new House();
  }

  update(canvasWidth) {
    this.house.update(canvasWidth);
  }

  draw(ctx) {
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = "white";
    ctx.moveTo(0, 350);
    ctx.lineTo(0, 100);
    ctx.lineTo(500, 100);
    ctx.lineTo(500, 350);
    ctx.fill();
    ctx.restore();

    this.trees.forEach((tree) => {
      tree.update(ctx);
      tree.draw(ctx);
    });

    this.house.draw(ctx);
  }
}

Finally, we achieved the image as shown in the video above. You can access the code via the GitHub link. Feel free to clone it, make your modifications, and leave a link to your work here in the comments.

Resources:

https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame