{
  "article_dcfc9a70a6f8": {
    "timestamp": 1746588721.1628811,
    "data": {
      "id": "dcfc9a70a6f8",
      "title": "Software Engineering Is Not About Typing, It\u2019s About Thinking",
      "subtitle": "Best practices in software engineering prioritise and reward repetitive work.",
      "author": "07a9707b9f1e",
      "publication_id": "*Self-Published*",
      "published_at": "2025-04-10 14:09:44",
      "last_modified_at": "2025-04-10 14:09:44",
      "boosted_at": "",
      "tags": [
        "coding",
        "software-engineering",
        "sdi-partners",
        "hedge-funds",
        "quantitative-strategies"
      ],
      "topics": [
        "programming"
      ],
      "claps": 1811,
      "voters": 904,
      "word_count": 1642,
      "responses_count": 1,
      "reading_time": 6.39622641509434,
      "url": "https://medium.com/@SDI_Partners/software-engineering-is-not-about-typing-its-about-thinking-dcfc9a70a6f8",
      "unique_slug": "software-engineering-is-not-about-typing-its-about-thinking-dcfc9a70a6f8",
      "image_url": "https://miro.medium.com/1*pRSPaYJvobMKnMdID45a9g.jpeg",
      "lang": "en",
      "is_series": false,
      "is_locked": false,
      "is_shortform": false,
      "top_highlight": "",
      "content": "Software Engineering Is Not About Typing, It's About Thinking\n\nBest practices in software engineering prioritise and reward repetitive work. They support working in ways that allow us to make frequent decisions and adapt to changing situations. These ideas are almost universal and appear to be necessary for successful large-scale engineering initiatives, although the concept is sometimes taken too far, which can be detrimental. While it is nearly always a good idea to be able to iterate rapidly and alter our thoughts, this does not mean that we should not take the time to think before acting.\n\nWhen confronted with an issue, it is frequently more productive to first thoroughly analyse the universe of potential solutions than leaping quickly to thoughts of \"how can I fix this with code\". By the time code begins to flow into an editor, there should be a clear understanding of the general plan; what is being built towards? Which principles are being programmed against? Should new core notions be introduced to this section of code to help with implementation? Which preexisting concepts will need to be modified? It's very simple to wind up just \"coding by accident\" without answers to these and other problems, wading through unforeseen problem after problem until eventually solution emerges that seems to work well enough, but most likely isn't implemented as well as it could've been.\n\nThe more inexperienced an engineer is, the stranger this may sound to them. After all, their job is to write code, so how can thinking be more valuable than actually doing? One of the best explanations can be found in a pithy quote for which I've been unable to find a source:\n\nWeeks of coding can save you hours of planning.\n\nThe point is that it doesn't matter how rapidly someone can create code if they're doing it for the wrong cause. One of the worst potential outcomes for a software engineer is to spend days or weeks working on a solution only to discover that they've been constructing the wrong thing the whole time. Of course, this isn't always the engineer's fault (and agile methodologies should help to identify problems like this earlier in the process), but the fact remains that there is almost always more than each of us can do individually to ensure that we're solving the right problems in the best way possible.\n\nThe idea can also be difficult to implement in practice for many reasons:\n\nIf the problem is completely novel, attempting to write some code can be a good way to better understand the problem space\n\nWriting code is, for many engineers, a lot more fun and approachable than sitting around and thinking about problems in the abstract\n\nThere is a lot of uncertainty involved in abstract thought of this nature; how does one know that they're thinking about the right things?\n\nSpending too much time thinking and planning ahead of time can be just as bad as not spending enough; how does one know when to stop thinking and start doing?\n\nOne technique I prefer to take is to establish what I consider to be the basic concepts that underpin the situation. Most difficulties can be broken down into smaller ideas that are more or less independent of one another. This should sound familiar to most engineers because it is quite close to the essential software design principles of coupling and cohesion. Decoupling is primarily a technical procedure, whereas identifying these key notions is theoretical. The goal is to look for concepts within the problem itself so that we may construct our technological bounds around the conceptual boundaries that exist within the core of the challenge at hand. More specifically, the best outcome is when the identified concepts are loosely coupled, yet highly cohesive.\n\nConsider a command-line application that can produce devcontainer specs for users by declaratively integrating tools rather than requiring them to manually write the configuration files. Writing devcontainers specifications and their corresponding dockerfiles can be a bit of a pain because of the unexpected interactions between the running container and the user's development environment; for example, the container's timezone should be synchronised with that of the user, the UID of the user in the container should match the UID of the external user, and SSH passthrough authentication should \"just work\", but these are not features that devcontainers provides. The idea is that the tool should be able to take a simplified configuration file that allows the user to say: \"I want to use Rust, Git, Vim, and the Oil shell\", click a button, and get a fully-instrumented and repeatable development environment.\n\nConsider forcing yourself to think about this problem: what key notions can you uncover that would make sense to build this tool around? Once you've finished, expand the section below to see what I discovered. Are your concepts different than mine? Maybe I overlooked something!\n\nCore Concepts\n\nRepository: the highest-level construct supported by the tooling; usually a versioned-controlled source repository, can hold one or more Projects\n\nProject: a desired development experience associated with a subset of its Repository. Has a single Configuration at any point in time\n\nConfiguration: a point-in-time instance of a Project. Each Configuration generates a single unique Devcontainers spec and associated Docker image\n\nHost: the host environment from which the tool is being executed, used as a source for information that must be injected into a Configuration\n\nEnvironment: an actively running instance of a Configuration, usually managed by the Editor\n\nEditor: the source code editor that will be used to run the Devcontainer\n\nTool: an individual piece of functionality that can be composed with other Tools to provide a development environment\n\nWhile this is a simplified list, it should be evident that these are concepts related to the problem rather than specific technical decisions. Nothing in the list above specifies how the tool will deal with any of these notions; it simply states that they exist and should be examined during development. That is one of the reasons it is critical to think before creating code: we want to avoid anchoring our cognitive process to previous experiences.\n\nMore technical questions then arise from consideration of these concepts:\n\nShould Repositories be restricted to containing only a single project? How might that effect users of monorepos?\n\nIt's possible that running Environments will drift from the current Configuration (if an environment is left running after the configuration is modified); does this matter?\n\nThe Configuration is likely to have to understand the different Editors supported by the tool; how should that be accomplished?\n\nHow should the tool deal with different Host platforms?\n\nHow can Tools be composed with one another when generating a final specification?\n\nAnd from here, the ability to begin iterative development as usual against these concept emerges.\n\nIt's important to note that I'm not advocating for design by committee, waterfall development, architecture astronauts, or any other anti-patterns that upset engineers who simply want to get things done. Thinking before typing is an individual action that any engineer can practise to potentially improve the end results of the work they produce. Writing some code to explore the problem space, for example, is a fantastic idea - but if you're going to get started right away, you might want to remind yourself to consider tossing that experimental code away and thinking about the problem before you go too far down any single road. Especially if problem discovery is the purpose of a prototype, the possibility of falling into the XY problem is ever-present.\n\nAnother aspect of this idea that I find very useful is that it can be used to help explain some of the difficulties involved in software engineering to less technical individuals, especially stakeholders and executives. Measurement of engineering teams, for example, is a hot topic lately off the tails of the success of DORA metrics, the relatively recent release of the SPACE framework, and then the unfortunate McKinsey system that has drawn some misgivings from experienced engineering leaders.\n\nSPACE, in particular, does an excellent job of recognising that there is much more to engineering than the code that an engineer creates. While many people struggle to understand the complexities of the development process, it is an engineering leader's responsibility to advocate for their teams and help stakeholders understand where time is spent and why things take as long as they do. Focusing on the importance of planning, design, and thinking can help leaders express these topics in terms that everyone, regardless of technical ability, can grasp.\n\nBecause most software engineering is an inherently creative endeavor, it's difficult to distill the daily activities of an engineer down to the type of cleanly measurable metrics that many executives (particularly those with less familiarity with the engineering process) would like to see. The glue engineer for example may be critical to the overall function of their team, but any attempts to measure that individual's impact by focusing on their issue completion or commit history is bound to fail in the general case. This is why experienced engineering leaders try to focus more on measuring outcomes over outputs.\n\nThe most interesting aspect of this difficulty of measurement is that the difficulty tends to grow with the seniority of the engineer in question. The more experienced and impactful someone is, the more likely it is that they're impact is coming from intangibles like their ability to influence others. While this is a generalization, there's a good reason that many of the open source engineering progression frameworks focus on influence rather than output at their highest engineering levels. These are just a few of the tools that can be used to help socialize this type of understanding of the SDLC throughout an organization.\n\nSo, every now and then considering reminding your engineers: software engineering is about thinking, not typing."
    }
  },
  "content_dcfc9a70a6f8": {
    "timestamp": 1746588721.627436,
    "data": "Software Engineering Is Not About Typing, It's About Thinking\n\nBest practices in software engineering prioritise and reward repetitive work. They support working in ways that allow us to make frequent decisions and adapt to changing situations. These ideas are almost universal and appear to be necessary for successful large-scale engineering initiatives, although the concept is sometimes taken too far, which can be detrimental. While it is nearly always a good idea to be able to iterate rapidly and alter our thoughts, this does not mean that we should not take the time to think before acting.\n\nWhen confronted with an issue, it is frequently more productive to first thoroughly analyse the universe of potential solutions than leaping quickly to thoughts of \"how can I fix this with code\". By the time code begins to flow into an editor, there should be a clear understanding of the general plan; what is being built towards? Which principles are being programmed against? Should new core notions be introduced to this section of code to help with implementation? Which preexisting concepts will need to be modified? It's very simple to wind up just \"coding by accident\" without answers to these and other problems, wading through unforeseen problem after problem until eventually solution emerges that seems to work well enough, but most likely isn't implemented as well as it could've been.\n\nThe more inexperienced an engineer is, the stranger this may sound to them. After all, their job is to write code, so how can thinking be more valuable than actually doing? One of the best explanations can be found in a pithy quote for which I've been unable to find a source:\n\nWeeks of coding can save you hours of planning.\n\nThe point is that it doesn't matter how rapidly someone can create code if they're doing it for the wrong cause. One of the worst potential outcomes for a software engineer is to spend days or weeks working on a solution only to discover that they've been constructing the wrong thing the whole time. Of course, this isn't always the engineer's fault (and agile methodologies should help to identify problems like this earlier in the process), but the fact remains that there is almost always more than each of us can do individually to ensure that we're solving the right problems in the best way possible.\n\nThe idea can also be difficult to implement in practice for many reasons:\n\nIf the problem is completely novel, attempting to write some code can be a good way to better understand the problem space\n\nWriting code is, for many engineers, a lot more fun and approachable than sitting around and thinking about problems in the abstract\n\nThere is a lot of uncertainty involved in abstract thought of this nature; how does one know that they're thinking about the right things?\n\nSpending too much time thinking and planning ahead of time can be just as bad as not spending enough; how does one know when to stop thinking and start doing?\n\nOne technique I prefer to take is to establish what I consider to be the basic concepts that underpin the situation. Most difficulties can be broken down into smaller ideas that are more or less independent of one another. This should sound familiar to most engineers because it is quite close to the essential software design principles of coupling and cohesion. Decoupling is primarily a technical procedure, whereas identifying these key notions is theoretical. The goal is to look for concepts within the problem itself so that we may construct our technological bounds around the conceptual boundaries that exist within the core of the challenge at hand. More specifically, the best outcome is when the identified concepts are loosely coupled, yet highly cohesive.\n\nConsider a command-line application that can produce devcontainer specs for users by declaratively integrating tools rather than requiring them to manually write the configuration files. Writing devcontainers specifications and their corresponding dockerfiles can be a bit of a pain because of the unexpected interactions between the running container and the user's development environment; for example, the container's timezone should be synchronised with that of the user, the UID of the user in the container should match the UID of the external user, and SSH passthrough authentication should \"just work\", but these are not features that devcontainers provides. The idea is that the tool should be able to take a simplified configuration file that allows the user to say: \"I want to use Rust, Git, Vim, and the Oil shell\", click a button, and get a fully-instrumented and repeatable development environment.\n\nConsider forcing yourself to think about this problem: what key notions can you uncover that would make sense to build this tool around? Once you've finished, expand the section below to see what I discovered. Are your concepts different than mine? Maybe I overlooked something!\n\nCore Concepts\n\nRepository: the highest-level construct supported by the tooling; usually a versioned-controlled source repository, can hold one or more Projects\n\nProject: a desired development experience associated with a subset of its Repository. Has a single Configuration at any point in time\n\nConfiguration: a point-in-time instance of a Project. Each Configuration generates a single unique Devcontainers spec and associated Docker image\n\nHost: the host environment from which the tool is being executed, used as a source for information that must be injected into a Configuration\n\nEnvironment: an actively running instance of a Configuration, usually managed by the Editor\n\nEditor: the source code editor that will be used to run the Devcontainer\n\nTool: an individual piece of functionality that can be composed with other Tools to provide a development environment\n\nWhile this is a simplified list, it should be evident that these are concepts related to the problem rather than specific technical decisions. Nothing in the list above specifies how the tool will deal with any of these notions; it simply states that they exist and should be examined during development. That is one of the reasons it is critical to think before creating code: we want to avoid anchoring our cognitive process to previous experiences.\n\nMore technical questions then arise from consideration of these concepts:\n\nShould Repositories be restricted to containing only a single project? How might that effect users of monorepos?\n\nIt's possible that running Environments will drift from the current Configuration (if an environment is left running after the configuration is modified); does this matter?\n\nThe Configuration is likely to have to understand the different Editors supported by the tool; how should that be accomplished?\n\nHow should the tool deal with different Host platforms?\n\nHow can Tools be composed with one another when generating a final specification?\n\nAnd from here, the ability to begin iterative development as usual against these concept emerges.\n\nIt's important to note that I'm not advocating for design by committee, waterfall development, architecture astronauts, or any other anti-patterns that upset engineers who simply want to get things done. Thinking before typing is an individual action that any engineer can practise to potentially improve the end results of the work they produce. Writing some code to explore the problem space, for example, is a fantastic idea - but if you're going to get started right away, you might want to remind yourself to consider tossing that experimental code away and thinking about the problem before you go too far down any single road. Especially if problem discovery is the purpose of a prototype, the possibility of falling into the XY problem is ever-present.\n\nAnother aspect of this idea that I find very useful is that it can be used to help explain some of the difficulties involved in software engineering to less technical individuals, especially stakeholders and executives. Measurement of engineering teams, for example, is a hot topic lately off the tails of the success of DORA metrics, the relatively recent release of the SPACE framework, and then the unfortunate McKinsey system that has drawn some misgivings from experienced engineering leaders.\n\nSPACE, in particular, does an excellent job of recognising that there is much more to engineering than the code that an engineer creates. While many people struggle to understand the complexities of the development process, it is an engineering leader's responsibility to advocate for their teams and help stakeholders understand where time is spent and why things take as long as they do. Focusing on the importance of planning, design, and thinking can help leaders express these topics in terms that everyone, regardless of technical ability, can grasp.\n\nBecause most software engineering is an inherently creative endeavor, it's difficult to distill the daily activities of an engineer down to the type of cleanly measurable metrics that many executives (particularly those with less familiarity with the engineering process) would like to see. The glue engineer for example may be critical to the overall function of their team, but any attempts to measure that individual's impact by focusing on their issue completion or commit history is bound to fail in the general case. This is why experienced engineering leaders try to focus more on measuring outcomes over outputs.\n\nThe most interesting aspect of this difficulty of measurement is that the difficulty tends to grow with the seniority of the engineer in question. The more experienced and impactful someone is, the more likely it is that they're impact is coming from intangibles like their ability to influence others. While this is a generalization, there's a good reason that many of the open source engineering progression frameworks focus on influence rather than output at their highest engineering levels. These are just a few of the tools that can be used to help socialize this type of understanding of the SDLC throughout an organization.\n\nSo, every now and then considering reminding your engineers: software engineering is about thinking, not typing."
  },
  "article_8f376ee6a406": {
    "timestamp": 1746588722.736845,
    "data": {
      "id": "8f376ee6a406",
      "title": "Different Styles of Engineering Leadership",
      "subtitle": "Micromanagement, Center-out Leadership, Psychological Safety Leadership, and others",
      "author": "c6584fe2de9d",
      "publication_id": "de90c1659654",
      "published_at": "2024-04-24 15:50:23",
      "last_modified_at": "2024-04-24 15:50:23",
      "boosted_at": "",
      "tags": [
        "leading-engineers",
        "engineering-management",
        "leadership",
        "management",
        "startup"
      ],
      "topics": [
        "leadership",
        "work",
        "programming"
      ],
      "claps": 794,
      "voters": 259,
      "word_count": 2114,
      "responses_count": 14,
      "reading_time": 8.81069182389937,
      "url": "https://blog.practicalengineering.management/different-styles-of-engineering-leadership-8f376ee6a406",
      "unique_slug": "different-styles-of-engineering-leadership-8f376ee6a406",
      "image_url": "https://miro.medium.com/1*FpnONEuTSDwG-aNoSMdV6w.png",
      "lang": "en",
      "is_series": false,
      "is_locked": false,
      "is_shortform": false,
      "top_highlight": "As an engineering leader, you set expectations (such as technical standards, non-functional requirements, product acceptance criteria, hypotheses, principles and guidelines). But then you invite the team to provide their input and collaboratively work on the problems ahead - you set WHAT, and they decide on HOW."
    }
  },
  "content_8f376ee6a406": {
    "timestamp": 1746588723.374075,
    "data": "Different Styles of Engineering Leadership\n\nMicromanagement, Center-out Leadership, Psychological Safety Leadership, and others\n\nThe beauty of software engineering comes from the many different ways of solving challenges ahead of us. Our work can be like receiving an unlimited set of LEGO bricks without instructions, just an end goal to achieve. We can be builders, architects, designers, or inventors.\n\nAnd then we become managers. We set expectations, make decisions, motivate people, and ensure execution\u2014classic, boring managerial work. But that's not entirely true. As engineering leaders, we can also bring some creativity to our work, e.g., through mixing different styles of managing people.\n\nIn today's article, we will explore some of them, i.e.:\n\nMicromanagement\n\nCenter-out Leadership\n\nTop-down Leadership\n\nTransactional Leadership\n\nDevelopmental Leadership\n\nTransformational Leadership\n\nPsychological Safety Leadership (based on physiopsychological research and the Polyvagal Theory)\n\nI hope these insights will help you build your unique style for engineering leadership!\n\nMicromanagement\n\nOkay, firstly, let's face this one since micromanagement is also a style. It exists because not all organizations provide the necessary support to their fresh leaders. Because of that, micromanagement is quite common - also in companies that are seen as successful.\n\nHere are a few characteristics of it:\n\nConstant Supervision: monitoring every aspect of a teammate's work and requiring frequent status updates.\n\nLack of Delegation: not delegating tasks or responsibilities, preferring to do things themselves.\n\nExcessive Control: dictating exactly how tasks should be done, even when the employee has the skills to handle them independently.\n\nFrequent Corrections: lack of trust in the employee's abilities and constant correction of the employee's work.\n\nSometimes it's hard to blame micromanagers - esp. the ones who were the most senior engineers in a team (or the organization's old guards). They already \"saw things\", have deep domain knowledge, and remember every single hack they implemented during their journey. However, we must remember that this style of leadership reduces the autonomy of others and lowers the sense of ownership, which can be destructive for engineering teams.\n\nCenter-out Leadership\n\nLast year, significant news emerged about the rebound of Barnes & Noble, a bookstore chain previously on a straight path to liquidation. 2023 marked the first year in recent memory when this company expanded rather than contracted.\n\nThis success was primarily attributed to their CEO, James Daunt, who implemented a strategy that involved:\n\nGranting autonomy to local managers to make more decisions about their stores (such as which books to stock, ensuring the selection is relevant to their customers),\n\nReducing the non-book offerings in stores, which also decreased the cognitive load on managers.\n\nJames Daunt's actions were a classic example of a transformation from top-down leadership to center-out leadership.\n\nIn a center-out leadership, decision rights are distributed within some set of boundaries. This means teams and individuals have the autonomy to make decisions within their areas of expertise, but a framework is still in place to ensure alignment with overall goals and ways of working.\n\nAs an engineering leader, you set expectations (such as technical standards, non-functional requirements, product acceptance criteria, hypotheses, principles and guidelines). But then you invite the team to provide their input and collaboratively work on the problems ahead - you set WHAT, and they decide on HOW.\n\nFor you, as an engineering leader, the center-out approach opens new ways of working with your team and product stakeholders. By reducing your cognitive load required to always be on top of everything, you can shift your attention to:\n\nBuilding your understanding of the product context,\n\nGrowing and empowering your people,\n\nManaging the strategic direction of the technology you oversee.\n\nThe center-out approach is not without its costs and risks. The biggest challenges include:\n\nComplex Decision-Making: Without effective facilitation, discussions may drag on for months without reaching a consensus.\n\nPotential for Chaos and Misalignment: Center-out leadership requires clear boundaries and effective collaboration.\n\nNeed for Strong Leadership Skills: In addition to technical expertise, leaders must also develop skills in coaching, facilitating, and empowering their teams effectively.\n\nTop-down Leadership\n\nSometimes, the environment doesn't allow us to go immediately into a center-out approach. These scenarios include:\n\nBootstrapping the team, ways of working, and common standards,\n\nTaking the lead during a crisis,\n\nMinimizing variance when we expect exact results (e.g., financial reports).\n\nIn such cases, a more classic, top-down approach to leadership can be a better fit.\n\nIn a top-down approach, management retains data and decision-making authority. The leader develops or selects the best solutions, and their direct reports are expected to execute these directives. This approach can often be observed at the organizational level, where senior management makes strategic decisions without lower-level consultation and expects teams to implement the decisions made.\n\nThough often viewed as micromanagement, the top-down approach has its strengths. It brings:\n\nEfficiency: Decisions can be made swiftly without needing consensus from multiple stakeholders.\n\nClarity: Clear directives and expectations can simplify roles and responsibilities.\n\nControl: Managers can enforce policies and standards effectively.\n\nBut the main costs and risks are:\n\nLack of employee engagement,\n\nRisk of misalignment,\n\nLeader's cognitive overload\n\nTo read more about the differences between Center-out and Top-down Leadership styles, check the Practical Engineering Management article: Top-down Leadership vs. Center-out Leadership.\n\nTransactional Leadership\n\nTransactional leadership is a traditional top-down approach focused on rewards and punishments, which are supposed to optimize job performance. In this style, leaders pay attention to constraints, mostly around limited resources (time and workforce).\n\nA transactional leader constantly analyzes cost-benefits and weighs competing needs. They continuously \"allocate resources,\" trying to find the most optimal configuration of the team, its priorities while minimizing waste and idle time.\n\nFor transactional leaders usually, there are too few people and too many initiatives to handle. In that case, the best a transactional leader can do is to:\n\nRecruit more people or better people,\n\nImprove the current team's allocation based on perceived outcomes (better productivity, profitability, returns, etc.).\n\nBut the reality is much more complex. In the dynamic systems we operate, we cannot accurately forecast the time needed to complete the work as a whole, nor can we get precise information from each of our teammates about the time they need to finish their piece.\n\nIt has been proven that finding the most optimal scheduling solution for complex systems is impossible - \"job-shop scheduling\" is an NP-hard problem, meaning that for some scheduling problems, we won't find a solution in finite time.\n\nAlso, hiring more people isn't always a good solution. As Price's Law states, the square root of the total number of people in a domain does half of the work. For example, if you have an engineering team with 100 people, Price's Law suggests that 10 people (the square root of 100) will produce 50% of the results. Hiring more also brings more complexity and challenges - even more scheduling, more priorities to handle, and more relationships to maintain.\n\nEach of us occasionally plays transactional leader\u2014we optimize allocation, hire more people, and try to improve productivity. But it's worth remembering that we can do more than just play \"optimization chess \"with \"available resources.\"\n\nDevelopmental Leadership\n\nWhile transactional leadership focuses on acquiring more resources, developmental leadership, before asking for more hires, considers how to grow the current team's creativity and problem-solving capabilities so potential new team members won't operate in the same fashion.\n\nTo be a developmental leader, you can't just be inspirational and motivational. Your job is to constantly improve the environment so your team can do great work.\n\nIt's not only about investing in people's growth, as the word \"developmental\" might suggest. Apart from that, you must also focus on improving the conditions under which work is executed.\n\nAn extensive source of knowledge here can be the book \"Wiring Winning Organizations\", which introduces three core aspects of transforming an organization:\n\nSlowification - making the problem-solving process easier.\n\nSimplification - making the problems themselves easier.\n\nAmplification - calling out occurring problems loud and clear.\n\nDevelopmental leadership is about looking beyond the day-to-day and investing in your team's future. This style encourages us to create an environment where everyone feels empowered to solve problems and innovate.\n\nFor more, you can read my article on Practical Engineering Management, where I explore the differences between transactional and developmental leadership and provide some practical examples for implementing them in our work.\n\nRead it here: Developmental Leadership vs. Transactional Leadership\n\nTransformational Leadership\n\nActually, transformational leadership isn't a different style but rather a synonym for developmental leadership, as described earlier. Yet I put it here because of certain management style aspects connected to this particular term.\n\nTransformational leaders focus on improving software delivery performance by enhancing the team's technical and product management capabilities rather than driving outcomes directly (top-down or transactional leadership).\n\nDORA studied the role of Transformational Leadership and proved that it is highly correlated with SDLC and Organizational performance. According to the research, there are five specific characteristics of this approach:\n\nVisionary,\n\ninspirational communication,\n\nintellectual stimulation,\n\nsupportive leadership,\n\npersonal recognition.\n\nThe leaders of the most high-performing companies usually presented strong behaviors across each of them.\n\nTo read more, check DORA's explanation of Transformational Leadership: https://dora.dev/devops-capabilities/cultural/transformational-leadership/\n\nIf you want to be an influential and successful leader, I recommend self-assessing these five transformational leadership characteristics each week. If you are looking for a more structured framework that can help you with that, check the Practical Engineering Management's Leader's Week.\n\nPsychological Safety Leadership\n\nThe list of leadership styles wouldn't be complete without some materials that come directly from the study of human behavior - psychology.\n\nMany of us have heard about Google's research, which says that psychological safety is a critical factor in high-performing teams.\n\n\"In a team with high psychological safety, teammates feel safe to take risks around their team members. They feel confident that no one on the team will embarrass or punish anyone else for admitting a mistake, asking a question, or offering a new idea.\"\n\nTo explore the subject deeper, we shared some insights on Practical Engineering Management, from the latest physiopsychological research and the Polyvagal Theory.\n\nPolyvagal Theory (PVT), developed by American psychologist and neuroscientist Stephen Porges, suggests that our autonomic state acts as a mediator, guiding us from vulnerability in threatening situations to accessibility in supportive environments, aided by safety cues and appropriate social support.\n\nIn simpler terms, neuroception engages the resources of the Autonomous Nervous System (ANS) and regulatory systems based on the presence or absence of safety. It serves as our internal \"safety radar,\" operating subconsciously to continually assess our environment through:\n\nInternal Check (Inside): Am I safe? Do I have what I need?\n\nInterpersonal Check (Between): Am I safe? Am I seen, liked, understood, supported?\n\nEnvironmental Check (Outside): Am I safe here? Do I belong here?\n\nSafety is not just a concept but an embodied state, fundamental to regulation. Based on PVT, there are six basic strategies to make you and your team feel well, safe, and productive:\n\nClarity: Clear communication about job responsibilities, salary, benefits, and promotion criteria.\n\nPredictability: A leader should be predictable in their demeanor - consistent, stable, and attentive - making it clear what others can expect from them.\n\nBelonging: Nurturing a sense of belonging within the team enhances work atmosphere and effectiveness.\n\nFlexibility and Sensitivity: Support employees through personal hardships, reinforcing safety and stability rather than conditional support.\n\nCo-regulation: Effective teams are characterized by ongoing relationships based on mutual regulation and trust.\n\nA Sensory-Friendly Environment: Reducing sensory overload helps facilitate deep work. Leaders should strive to minimize unnecessary distractions in the work environment.\n\nCheck the latest article on Practical Engineering Management: Safety Leadership and Neuroception - How the Polyvagal Theory Enhance Workplace Safety, Engagement, and Performance.\n\nEnd words\n\nEffective engineering leadership embraces a variety of styles, each with its own set of advantages and challenges. The best leaders blend these styles, continuously evaluating and adapting their approach to foster a culture of growth, collaboration, and high performance.\n\nAs you navigate your leadership journey, remain flexible and responsive to the evolving dynamics of your team.\n\nYou can also explore more content for engineering managers on practicalengineering.management. You will find there practical strategies for effective engineering leadership.\n\nJoin the community of impactful leaders to bridge the gap between inspiration and implementation with actionable steps that empower your team, boost trust, and drive real-world results.\n\nIf you would like to discuss any of your challenges, don't hesitate to reach out to me at mirek@practicalengineering.management."
  }
}